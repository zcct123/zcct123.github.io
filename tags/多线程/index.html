<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>标签: 多线程 - ZCCT</title><link rel="manifest" href="/zclvct.io/manifest.json"><meta name="application-name" content="ZCCT"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZCCT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ZCCT"><meta property="og:url" content="https://zcct123.github.io/zclvct.io"><meta property="og:site_name" content="ZCCT"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zcct123.github.io/zclvct.io/img/og_image.png"><meta property="article:author" content="zcct"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zcct123.github.io/zclvct.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zcct123.github.io/zclvct.io"},"headline":"ZCCT","image":["https://zcct123.github.io/zclvct.io/img/og_image.png"],"author":{"@type":"Person","name":"zcct"},"publisher":{"@type":"Organization","name":"ZCCT","logo":{"@type":"ImageObject","url":"https://zcct123.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/zclvct.io/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/zclvct.io/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/zclvct.io/"><img src="/zclvct.io/img/logo.svg" alt="ZCCT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/zclvct.io/">主页</a><a class="navbar-item" href="/zclvct.io/archives">档案</a><a class="navbar-item" href="/zclvct.io/categories">分类</a><a class="navbar-item" href="/zclvct.io/tags">标签</a><a class="navbar-item" href="/zclvct.io/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/zclvct.io/tags/">标签</a></li><li class="is-active"><a href="#" aria-current="page">多线程</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:11.033Z" title="2025/5/16 11:13:11">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">16 分钟读完 (大约2470个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/">java线程运行原理</a></p><div class="content"><p>[TOC]</p>
<h3 id="基础解释"><a href="#基础解释" class="headerlink" title="基础解释"></a>基础解释</h3><p><strong>1.栈帧（存在于java栈）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      method1(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x + <span class="number">1</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span>method2();</span><br><span class="line">      System.out.println(y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>idea debug</strong><br><img src="/zclvct.io/media/17332745457143/17332745820135.jpg"></p>
<p><strong>图解</strong><br><img src="/zclvct.io/media/17332745457143/17332745982553.jpg"></p>
<h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><p><img src="/zclvct.io/media/17332745457143/17332746124588.jpg"></p>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>因为以下一些原因导致CPU不再执行当前线程，转而执行另一个线程的代码 叫做上下文切换</p>
<p>原因</p>
<ul>
<li>线程的cpu时间片用完了</li>
<li>垃圾回收</li>
<li>优先级高的线程需要运行</li>
<li>&#x3D;&#x3D;主动：&#x3D;&#x3D;  线程自己调用了 sleep、yield、wait、join、park、synchronized、lock等方法</li>
</ul>
<p>当Context Switch发生时，需要保存当前线程的状态，并恢复另一个线程，对应jiava中的程序计数器（PC register），他的作用是记住下一条jvm指令地址</p>
<ul>
<li>频繁切换会影响性能</li>
</ul>
<h3 id="线程中常见方法"><a href="#线程中常见方法" class="headerlink" title="线程中常见方法"></a>线程中常见方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出IllegalThreadStateException</td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动后会调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束,最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的 id id 唯一</td>
<td></td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断， 不会清除 打断标记</td>
<td></td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，&#x3D;&#x3D;并清除打断标记&#x3D;&#x3D; ；如果打断的正在运行的线程，则会设置&#x3D;&#x3D;打断标记&#x3D;&#x3D; ；park 的线程被打断，也会设置 &#x3D;&#x3D;打断标记&#x3D;&#x3D;</td>
</tr>
<tr>
<td>interrupted</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除&#x3D;&#x3D;打断标记&#x3D;&#x3D;</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒休眠时让出 cpu 的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h4 id="1-run-和-start"><a href="#1-run-和-start" class="headerlink" title="1. run 和 start"></a>1. run 和 start</h4><ul>
<li>重写run（）方法写的是线程需要执行的代码</li>
<li>start（）是前程启动的方法</li>
</ul>
<h4 id="2-sleep-与-yield（让步-放弃）"><a href="#2-sleep-与-yield（让步-放弃）" class="headerlink" title="2. sleep 与 yield（让步;放弃）"></a>2. sleep 与 yield（让步;放弃）</h4><p><strong>2.1 sleep</strong></p>
<ul>
<li>sleep  执行 线程由 Running 进入 Timed_Waiting（阻塞）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">       <span class="meta">@SneakyThrows</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">   thread.start();</span><br><span class="line">   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;线程的状态：&quot;</span>+thread.getState());</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程的状态：TIMED_WAITING</span><br></pre></td></tr></table></figure>
<ul>
<li>线程可以使用interrupt方法打断正在睡眠的线程，这时 sleep方法会抛出 InterruptedException异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;sleep....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;wake up ....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;interrupt....&quot;</span>);</span><br><span class="line">        thread.interrupt();  <span class="comment">//叫醒</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">19:46:22 [t1] c.Test1 - <span class="built_in">sleep</span>....</span><br><span class="line">19:46:23 [main] c.Test1 - interrupt....</span><br><span class="line">19:46:23 [t1] c.Test1 - wake up ....</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line">	at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:953)</span><br><span class="line">	at com.zclvct.juc.test.ThreadTest1<span class="variable">$1</span>.run(ThreadTest1.java:85)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:823)</span><br></pre></td></tr></table></figure>
<ul>
<li>睡眠结束后的线程未必立刻执行</li>
<li>建议用TimeUnit的类进行睡眠</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;sleep....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                log.info(<span class="string">&quot;sleep end ....&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19:52:11 [t1] c.Test1 - <span class="built_in">sleep</span>....</span><br><span class="line">19:52:13 [t1] c.Test1 - <span class="built_in">sleep</span> end ....</span><br></pre></td></tr></table></figure>

<p><strong>2.1 yield  （让出、谦让）</strong></p>
<ul>
<li>调用yield（）会让当前线程让当前线程从Running 进入 Runnable 状态 ，然后调度其他线程</li>
<li>具体实现依赖于操作系统的调度器。<br>&#x3D;&#x3D; 就绪状态（Runnable）会被调度器调度  而  阻塞状态（Timed_Waiting）不会&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;;)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;======1 &quot;</span>+count++);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// Thread.yield();</span></span><br><span class="line">                System.out.println(<span class="string">&quot;=============2 &quot;</span>+count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2);</span><br><span class="line">        thread1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过yeild（）或设置优先级 在一定条件下 count的差值会变大<br><strong>2.3 线程优先级</strong></p>
</li>
<li><p>setPriority（） getPriority（） </p>
</li>
<li><p>优先级会提示调度器优先调度的线程，当时调度器课以忽略他 ， 他仅仅是提示作用</p>
</li>
<li><p>如果cpu防盲，那么优先级高的线程会获取更多的时间片，但cpu闲时几乎没有作用</p>
</li>
</ul>
<h4 id="2-join"><a href="#2-join" class="headerlink" title="2. join"></a>2. join</h4><ul>
<li>等待调用的线程运行结束</li>
</ul>
<p><strong>1.join 同步应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始。。。&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;开始。。。&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                log.info(<span class="string">&quot;结束。。。&quot;</span>);</span><br><span class="line">                i = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;th1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        log.info(<span class="string">&quot;结果为：&#123;&#125;&quot;</span>,i);</span><br><span class="line">        log.info(<span class="string">&quot;结束。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">30</span> [main] c.Test1 - 开始。。。</span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">30</span> [th1] c.Test1 - 开始。。。</span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">31</span> [th1] c.Test1 - 结束。。。</span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">31</span> [main] c.Test1 - 结果为：<span class="number">10</span></span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">31</span> [main] c.Test1 - 结束。。。·</span><br></pre></td></tr></table></figure>
<p><img src="/zclvct.io/media/17332745457143/17332746349608.jpg"></p>
<p><strong>1.join 等待最大时间</strong></p>
<ul>
<li>thread.join（1000） 设置等待最大时间  ，到时间则结束不继续等待线程执行完毕</li>
</ul>
<h4 id="2-interrupt-（打断）"><a href="#2-interrupt-（打断）" class="headerlink" title="2. interrupt （打断）"></a>2. interrupt （打断）</h4><p> <strong>打断 sleep 、 wait 、 join的线程</strong></p>
<ul>
<li>打断sleep线程，&#x3D;&#x3D;会清空打断状态、会抛出异常&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;sleep....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);  <span class="comment">// wait ， join ,sleep 被打断会清除打断标记</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;wake up ....&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;interrupt....&quot;</span>);</span><br><span class="line">        thread1.interrupt();  <span class="comment">//打断</span></span><br><span class="line">        log.debug(<span class="string">&quot;打断标记 &#123;&#125;&quot;</span>,thread1.isInterrupted());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">00</span> [t1] c.Test1 - sleep....</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">01</span> [main] c.Test1 - interrupt....</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">01</span> [t1] c.Test1 - wake up ....</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">01</span> [main] c.Test1 - 打断标记 <span class="literal">false</span></span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">	at com.zclvct.juc.test.ThreadTest1$<span class="number">1.</span>run(ThreadTest1.java:<span class="number">183</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">823</span>)</span><br></pre></td></tr></table></figure>
<p><strong>打断正常运行的线程线程</strong></p>
<ul>
<li>打断正常运行的线程线程  ，&#x3D;&#x3D;不会清空打断标记 ，不会抛出异常&#x3D;&#x3D; </li>
<li>isInterrupted（） 不会清除打断标记  static  interrupted （） 会清除打断标记 两者都是判断打断标记的放法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">                 <span class="keyword">if</span>(interrupted)</span><br><span class="line">                 &#123;</span><br><span class="line">                     log.info(<span class="string">&quot;被打断退出循环&quot;</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     thread1.start();</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">     log.info(<span class="string">&quot;interrupt....&quot;</span>);</span><br><span class="line">     thread1.interrupt();  <span class="comment">//打断</span></span><br><span class="line">     log.debug(<span class="string">&quot;打断标记 &#123;&#125;&quot;</span>,thread1.isInterrupted());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">00</span>:<span class="number">54</span> [main] c.Test1 - interrupt....</span><br><span class="line"><span class="number">21</span>:<span class="number">00</span>:<span class="number">54</span> [t1] c.Test1 - 被打断退出循环</span><br><span class="line"><span class="number">21</span>:<span class="number">00</span>:<span class="number">54</span> [main] c.Test1 - 打断标记 <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p> <strong>两阶段终止模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread monitor; <span class="comment">//监控线程</span></span><br><span class="line">        <span class="comment">// 启动监控线程</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">            monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> thread.isInterrupted();</span><br><span class="line">                    <span class="keyword">if</span>(interrupted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;打断我 ，我选择认输&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        log.info(<span class="string">&quot;执行监控功能&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;正在睡眠打断我，设置打断标记&quot;</span>);</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            monitor.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 停止监控线程</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">            monitor.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">TwoPhaseTermination</span> <span class="variable">twoPhaseTermination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">       twoPhaseTermination.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">       twoPhaseTermination.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">20</span> [Thread-<span class="number">3</span>] c.Test1 - 执行监控功能</span><br><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">21</span> [Thread-<span class="number">3</span>] c.Test1 - 执行监控功能</span><br><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">22</span> [Thread-<span class="number">3</span>] c.Test1 - 正在睡眠打断我，设置打断标记</span><br><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">22</span> [Thread-<span class="number">3</span>] c.Test1 - 打断我 ，我选择认输</span><br></pre></td></tr></table></figure>
<p><img src="/zclvct.io/media/17332745457143/17332746547474.jpg"></p>
<p><strong>打断park线程</strong></p>
<ul>
<li>打断park线程，不会清空打断状态</li>
<li>打断状态为真时再次park（）不会生效 可以利用 static interrupted清除打断状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;park。。&quot;</span>);</span><br><span class="line">                LockSupport.park(); </span><br><span class="line">                log.info(<span class="string">&quot;unpark....&quot;</span>);</span><br><span class="line">                log.info(<span class="string">&quot;打断状态 &#123;&#125;&quot;</span>,Thread.currentThread().isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;th1&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th1.interrupt();</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">48</span> [th1] c.Test1 - park。。</span><br><span class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">48</span> [th1] c.Test1 - unpark....</span><br><span class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">48</span> [th1] c.Test1 - 打断状态 <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>不推荐的方法</strong></p>
<ul>
<li>会破坏同步代码块，造成线程死锁<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop（）</td>
<td></td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend（）</td>
<td></td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume（）</td>
<td></td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h3><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会立即结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               log.info(Thread.currentThread().getName() +<span class="string">&quot; 运行结束&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;th1&quot;</span>);</span><br><span class="line">       th1.setDaemon(<span class="literal">true</span>);  <span class="comment">//设置线程为守护线程   </span></span><br><span class="line">       th1.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       log.info(<span class="string">&quot;主线程结束。。。&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">44</span>:<span class="number">57</span> [main] c.Test1 - 主线程结束。。。</span><br></pre></td></tr></table></figure>
<ul>
<li>垃圾回收线程就是守护线程</li>
<li>Tomcat中的Acceptor 和 Poller线程都是守护线程</li>
</ul>
<h3 id="线程的五种状态-（操作系统层面）"><a href="#线程的五种状态-（操作系统层面）" class="headerlink" title="线程的五种状态 （操作系统层面）"></a>线程的五种状态 （操作系统层面）</h3><p><img src="/zclvct.io/media/17332745457143/17332746697734.jpg"></p>
<h3 id="线程的六种状态（java层面）"><a href="#线程的六种状态（java层面）" class="headerlink" title="线程的六种状态（java层面）"></a>线程的六种状态（java层面）</h3><p><img src="/zclvct.io/media/17332745457143/17332746919747.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="comment">// runnable</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>); <span class="comment">// timed_waiting</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join(); <span class="comment">// waiting</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123; <span class="comment">// blocked    同一个对象加锁 他拿不到锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1 state &#123;&#125;&quot;</span>, t1.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t2 state &#123;&#125;&quot;</span>, t2.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t3 state &#123;&#125;&quot;</span>, t3.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t4 state &#123;&#125;&quot;</span>, t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5 state &#123;&#125;&quot;</span>, t5.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t6 state &#123;&#125;&quot;</span>, t6.getState());</span><br><span class="line">        System.in.read();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">36</span> [t3] c.TestState - running...</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t1 state NEW</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t2 state RUNNABLE</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t3 state TERMINATED  terminated</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t4 state TIMED_WAITING</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t5 state WAITING</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t6 state BLOCKED</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:21.419Z" title="2025/5/16 11:13:21">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">14 分钟读完 (大约2157个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/ReentrantLock/">ReentrantLock</a></p><div class="content"><p>[TOC]</p>
<p>相对于 synchronized</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁 （防止饥饿）</li>
<li>支持多个条件变量 （类似于支持多个 waitSet）<br>与synchronized一样 ，都支持可重入</li>
</ul>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">       reentrantLock.lock();</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//临界区</span></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         reentrantLock.unlock();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入是指同一个线程如果首个获取了这把锁，那么因为他是这把锁的拥有者，因此有权利再次获取这把锁<br>如果不是可重入锁，那么第二次获取锁，自己也会被挡住</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       lock.lock();    <span class="comment">//lock加锁是不可打断的</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;main &quot;</span>);</span><br><span class="line">           m1();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;m1 &quot;</span>);</span><br><span class="line">           m2();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>被动的被打断 避免死等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 没有竞争获取锁</span></span><br><span class="line">            <span class="comment">//有竞争进入阻塞队列，可以被其他线程用 interruput 打断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();   <span class="comment">//可打断锁   防止无限制等待 ，可以防止死锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.info(<span class="string">&quot;没有获得锁，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="comment">//if(!lock.tryLock())  //尝试获得锁  成功获得锁 失败不去阻塞队列等待   防止无限制等待</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(!lock.tryLock(<span class="number">2</span>,TimeUnit.SECONDS))   <span class="comment">//设置等待时间   也支持可打断的特性</span></span><br><span class="line">               &#123;</span><br><span class="line">                   log.info(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               log.info(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               log.info(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       lock.lock();</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>RenntranLock 默认是不公平锁<br>公平锁 可以解决饥饿问题 ， 设置公平锁会降低并发度 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span>  构造函数传入是否是公平锁   </span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是waitSet休息室，当条件不满足时进入waitSet等待</p>
<p>ReentranLock的条件变量比synchronized强大之处在于，支持多个条件变量</p>
<ul>
<li>synchronized 时那些不满足条件的线程都在一间休息室等消息</li>
<li>而ReentranLock支持多间休息室，可以分类</li>
</ul>
<p>使用流程</p>
<ul>
<li>await 前需要获取锁</li>
<li>await 执行后，会释放锁，静茹conditionObject等待</li>
<li>await 的线程被唤醒（或打断，超时）重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//创建一个姓的条件变量 （休息室）</span></span><br><span class="line">       <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">       <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="comment">//进入休息室等待</span></span><br><span class="line">       condition1.await();</span><br><span class="line">       condition1.signal();  <span class="comment">//唤醒等待的线程</span></span><br><span class="line">       condition2.signalAll(); <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步线程之顺序控制"><a href="#同步线程之顺序控制" class="headerlink" title="同步线程之顺序控制"></a>同步线程之顺序控制</h3><ol>
<li>使用synchrinized   wait（） notifyAll（）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">canRun</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!canRun)  <span class="comment">//防止虚假唤醒</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();  <span class="comment">// 不允许打印时 等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            canRun = <span class="literal">true</span>; <span class="comment">//设置允许打印</span></span><br><span class="line">            lock.notifyAll(); <span class="comment">//唤醒所有等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用RenntrinLock</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">   <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">canRun</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (!canRun &amp;&amp; lock.tryLock())  <span class="comment">//尝试获得锁 </span></span><br><span class="line">               &#123;</span><br><span class="line">                   condition.await();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">               canRun = <span class="literal">true</span>;</span><br><span class="line">               condition.signal();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       thread1.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用park 和 unpark</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">canRun</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span> (!canRun)</span><br><span class="line">          &#123;</span><br><span class="line">              LockSupport.park();</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">          canRun = <span class="literal">true</span>;</span><br><span class="line">          LockSupport.unpark(thread1);</span><br><span class="line">      &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步线程之交替输出"><a href="#同步线程之交替输出" class="headerlink" title="同步线程之交替输出"></a>同步线程之交替输出</h3><p>三个线程 t1输出 a t2输出 b t3输出c 让他们交替输出 abcabcabcabcabc 每个线程输出五次</p>
<ol>
<li>使用synchrinized   wait（） notifyAll（）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNatify</span> <span class="variable">waitNatify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNatify</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNatify.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNatify.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNatify.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNatify</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitNatify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str,<span class="type">int</span> waitFlag,<span class="type">int</span> nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNum; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != waitFlag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用ReentrinLock</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignalAll</span> <span class="variable">awaitSignalAll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignalAll</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignalAll.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignalAll.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignalAll.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignalAll.print(<span class="string">&quot;a&quot;</span>, a,b);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignalAll.print(<span class="string">&quot;b&quot;</span>, b,c);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignalAll.print(<span class="string">&quot;c&quot;</span>, c,a);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignalAll.lock();  <span class="comment">// 这里不获得锁 引起java.lang.IllegalMonitorStateException异常 （非法监视器状态异常）</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.signalAll();  <span class="comment">//目前线程全部在休息室等待  ， 这里设置 第一次被唤醒的休息室的线程 </span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignalAll.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignalAll</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignalAll</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current,Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNum; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();  <span class="comment">//三个线程调用 全部进入自己的休息室等待</span></span><br><span class="line">                System.out.printf(str);   <span class="comment">//等待结束 打印str</span></span><br><span class="line">                next.signalAll();  <span class="comment">// 唤醒下一个应该执行的休息室内的线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用park 和 unpark</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> Thread thread1;</span><br><span class="line">    <span class="keyword">static</span> Thread thread2;</span><br><span class="line">    <span class="keyword">static</span> Thread thread3;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ParkUnpark</span> <span class="variable">parkUnpark</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line">        thread1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, thread2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, thread3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, thread1);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        LockSupport.unpark(thread1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Thread next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNum; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.printf(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS   AbstractQueuedSynchronizer"></a>AQS   AbstractQueuedSynchronizer</h1><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException)</p>
<ul>
<li>tryAcquire           &#x2F;&#x2F;获取锁</li>
<li>tryRelease          &#x2F;&#x2F; 释放锁</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程    实际用了 park unpark 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不可重入锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Mylock</span> <span class="variable">mylock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mylock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            mylock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;枷锁成功&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mylock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            mylock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;枷锁成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                mylock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   自定义不可重入锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mylock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步器类   独占锁</span></span><br><span class="line">    <span class="keyword">class</span>  <span class="title class_">MySync</span>  <span class="keyword">extends</span> <span class="title class_">AbstractQueuedLongSynchronizer</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 加锁成功  设置线程位当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">long</span> arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);  <span class="comment">// state 是volatile 修饰，具有写屏障 保证之前的变量可见性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 创建条件变量</span></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span>  <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">// 加锁   （不成功进入等待队列 ）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>      <span class="comment">// 可打断锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">// 可打断锁  尝试一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">//  尝试加锁 （带超时时间）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">//  创建条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReentrinLock原理"><a href="#ReentrinLock原理" class="headerlink" title="ReentrinLock原理"></a>ReentrinLock原理</h1><p>构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();  <span class="comment">//  非公平锁</span></span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 加锁方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))   <span class="comment">// 改变 锁状态为加锁</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());  <span class="comment">//更改锁线程为当前线程</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);   <span class="comment">// 加锁失败</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/zclvct.io/media/17332929193096/17332929468048.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">		<span class="comment">// 尝试加锁                  放入阻塞队列  addWaiter  （）</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>尝试加锁<br><img src="/zclvct.io/media/17332929193096/17332929468078.png" alt="在这里插入图片描述"><br>acquireQueued </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;    <span class="comment">// 死循环 尝试获得锁</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();   <span class="comment">//前驱节点   </span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">// 如果前驱节点是头节点  说明头节点是第二的 才有资格尝试获得锁</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">// 尝试获取锁失败</span></span><br><span class="line">                    parkAndCheckInterrupt())   <span class="comment">//阻塞 </span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/zclvct.io/media/17332929193096/17332929468089.png" alt="在这里插入图片描述"><br>释放锁 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:07.867Z" title="2025/5/16 11:13:07">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">5 分钟读完 (大约738个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/">java线程池的参数设置</a></p><div class="content"><h2 id="在说如何对线程池优化之前重复一下线程的7大参数"><a href="#在说如何对线程池优化之前重复一下线程的7大参数" class="headerlink" title="在说如何对线程池优化之前重复一下线程的7大参数"></a>在说如何对线程池优化之前重复一下线程的7大参数</h2><ul>
<li><p>corePoolSize： 核心线程数，也是线程池中常驻的线程数，线程池初始化时默认是没有线程的，当任务来临时才开始创建线程去执行任务</p>
</li>
<li><p>maximumPoolSize： 最大线程数，在核心线程数的基础上可能会额外增加一些非核心线程，需要注意的是只有当workQueue队列填满时才会创建多于corePoolSize的线程(线程池总线程数不超过maxPoolSize)</p>
</li>
<li><p>keepAliveTime： 非核心线程的空闲时间超过keepAliveTime就会被自动终止回收掉，注意当corePoolSize&#x3D;maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程)；</p>
</li>
<li><p>unit： keepAliveTime的时间单位</p>
</li>
<li><p>workQueue： 用于保存任务的队列，可以为无界、有界、同步移交三种队列类型之一，当池子里的工作线程数大于corePoolSize时，这时新进来的任务会被放到队列中</p>
</li>
<li><p>threadFactory： 创建线程的工厂类，默认使用Executors.defaultThreadFactory()，也可以使用guava库的ThreadFactoryBuilder来创建</p>
</li>
<li><p>handler： 线程池无法继续接收任务(队列已满且线程数达到maximunPoolSize)时的饱和策略，取值有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p>
</li>
</ul>
<h2 id="核心线程设置"><a href="#核心线程设置" class="headerlink" title="核心线程设置"></a>核心线程设置</h2><h3 id="计算密集型"><a href="#计算密集型" class="headerlink" title="计算密集型"></a>计算密集型</h3><p>当线程执行的是计算密集型的任务，那么要尽量防止线程的上下文切换，所以要设置的线程数要较少一点，一般设置为 <strong>线程数 &#x3D; CPU核数+1，也可以设置成CPU核数*2</strong></p>
<h3 id="I-0密集型"><a href="#I-0密集型" class="headerlink" title="I&#x2F;0密集型"></a>I&#x2F;0密集型</h3><p>在 WEB 应用中 涉及到大量的 i&#x2F;o传输 ， 一旦发生IO，线程就会处于等待状态，当IO结束，数据准备好后，线程才会继续执行。我们可以多设置一些线程池中线程的数量，这样就能让在等待IO的这段时间内，其他线程可以去做其它事，提高并发处理效率。对于IO密集型应用：<br><strong>线程数 &#x3D; CPU核心数&#x2F;(1-阻塞系数) 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9</strong>。</p>
<h3 id="其他参数设置"><a href="#其他参数设置" class="headerlink" title="其他参数设置"></a>其他参数设置</h3><ol>
<li>根据不同的场景选择不同适合的拒绝策略 ， 也可以实现RejectedExecutionHandler接口自定义拒绝策略</li>
<li>使用线程工厂创建线程时正确的对线程命名，便于排查问题</li>
<li>我们也可以调用shutdown来手动终止线程池。如果我们忘记调用shutdown，为了让线程资源被释放，我们还可以使用keepAliveTime 和 allowCoreThreadTimeOut来达到目的</li>
<li>ThreadPoolExecutor提供了protected类型可以被覆盖的钩子方法，我们可以使用beforeExecute和afterExecute来记录线程之前前和后的一些运行情况</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:14.722Z" title="2025/5/16 11:13:14">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">14 分钟读完 (大约2072个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%20%E4%B9%8B%20CyclicBarrier%E3%80%81CountDownLatch%E3%80%81Semaphore%E7%9A%84%E7%90%86%E8%A7%A3/">juc 之 CyclicBarrier、CountDownLatch、Semaphore的理解</a></p><div class="content"><p>[TOC]</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>在 jdk 的注释中 是这样描述他的</p>
<blockquote>
<p>一个计数信号灯。从概念上讲，信号量维护一组许可证。如有必要，每个采集模块都会阻塞，直到获得许可证，然后再获取许可证。每次发布都会添加一个许可证，可能会释放一个阻塞收单机构。然而，没有使用实际的许可证对象；信号量只是保持可用数量的计数，并相应地进行操作。<br><strong>信号量通常用于限制可以访问某些（物理或逻辑）资源的线程数。</strong></p>
</blockquote>
<h2 id="Semaphore的使用"><a href="#Semaphore的使用" class="headerlink" title="Semaphore的使用"></a>Semaphore的使用</h2><p>老规矩先看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">semaphoreTest</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 获得许可&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 释放许可&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660359070454</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 获得许可</span><br><span class="line"><span class="number">1660359070454</span>:pool-<span class="number">1</span>-thread-<span class="number">4</span>: 获得许可</span><br><span class="line"><span class="number">1660359070455</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 获得许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">4</span>: 释放许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 释放许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 释放许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 获得许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">6</span>: 获得许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">5</span>: 获得许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">6</span>: 释放许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">8</span>: 获得许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">7</span>: 获得许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">5</span>: 释放许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 释放许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">9</span>: 获得许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">8</span>: 释放许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">10</span>: 获得许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">7</span>: 释放许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">9</span>: 释放许可</span><br><span class="line"><span class="number">1660359078472</span>:pool-<span class="number">1</span>-thread-<span class="number">10</span>: 释放许可</span><br></pre></td></tr></table></figure>
<p>从上边的代码中可以看出<br>信号量通常用于限制可以访问某些（物理或逻辑）资源的线程数。在上面的代码中可以看出 最多运行的资源数只有三个</p>
<h2 id="Semaphore-应用场景"><a href="#Semaphore-应用场景" class="headerlink" title="Semaphore 应用场景"></a>Semaphore 应用场景</h2><p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假 如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程 并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这 时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连 接。这个时候，就可以使用Semaphore来做流量控制，</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>在 jdk 的注释中 是这样描述他的</p>
<blockquote>
<p>一种同步辅助工具，允许一组线程都等待对方到达一个公共障碍点。CyclicBarrier在涉及固定大小的线程组的程序中很有用，这些线程偶尔必须相互等待。该屏障被称为循环屏障，因为它可以在等待线程释放后重新使用。</p>
<p>它要做的事情就是让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</p>
</blockquote>
<p>但在使用中需要注意的是 线程的数量 和  CyclicBarrier 构造函数中 parties 的数量要保持一直，以为他只维护了一个计数器，如果说线程数量是 4 CyclicBarrier 构造函数 的数量是三，那个 第四个线程执行时 会一直 Await，同样 如果 Await 三次 4个线程同样可以执行完成，但是这样就无法保证不同线程 是否到达 同一个 障碍点。</p>
<h2 id="CyclicBarrier-的使用"><a href="#CyclicBarrier-的使用" class="headerlink" title="CyclicBarrier 的使用"></a>CyclicBarrier 的使用</h2><p> 这里设置 三个线程数 同时  CyclicBarrier 允许的一组线程数为三</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">cyclicBarrierTest</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 正在准备&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 正在执行&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 执行完成&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660362890906</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在准备</span><br><span class="line"><span class="number">1660362890906</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在准备</span><br><span class="line"><span class="number">1660362890906</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在准备</span><br><span class="line"><span class="number">1660362892916</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在执行</span><br><span class="line"><span class="number">1660362892916</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在执行</span><br><span class="line"><span class="number">1660362892916</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在执行</span><br><span class="line"><span class="number">1660362894925</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 执行完成</span><br><span class="line"><span class="number">1660362894925</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 执行完成</span><br><span class="line"><span class="number">1660362894925</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 执行完成</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出 必须有足够 3 的线程到达障碍点 才能继续向下执行 ， 同时他可以设置多个障碍点</p>
<p>** CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrier- Action），用于在线程到达屏障时，优先执行barrierAction**<br>在 barrierAction 中打印 优先执行了 A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">cyclicBarrierTest01</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 优先执行了 A&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 正在准备&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 正在执行&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 执行完成&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660363624132</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在准备</span><br><span class="line"><span class="number">1660363624132</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在准备</span><br><span class="line"><span class="number">1660363624132</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在准备</span><br><span class="line"><span class="number">1660363626142</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 优先执行了 A</span><br><span class="line"><span class="number">1660363626143</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在执行</span><br><span class="line"><span class="number">1660363626143</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在执行</span><br><span class="line"><span class="number">1660363626143</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在执行</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 优先执行了 A</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 执行完成</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 执行完成</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 执行完成</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier-应用场景"><a href="#CyclicBarrier-应用场景" class="headerlink" title="CyclicBarrier 应用场景"></a>CyclicBarrier 应用场景</h2><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保 存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户 的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日 均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<blockquote>
<p>一种同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。使用给定计数初始化倒计时锁存器。由于调用倒计时方法，等待方法一直阻塞，直到当前计数达到零，然后释放所有等待线程，并立即返回任何后续的等待调用。<strong>这是一种一次性现象——计数无法重置。如果需要重置计数的版本，请考虑使用CyclicBarrier</strong>。</p>
</blockquote>
<blockquote>
<p>计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会 阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数 器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
</blockquote>
<h2 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">countDownLatchTest</span> <span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 执行完成&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程全部执行完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660364051584</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 执行完成</span><br><span class="line"><span class="number">1660364051584</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 执行完成</span><br><span class="line"><span class="number">1660364051584</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 执行完成</span><br><span class="line">线程全部执行完成</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch-应用场景"><a href="#CountDownLatch-应用场景" class="headerlink" title="CountDownLatch 应用场景"></a>CountDownLatch 应用场景</h2><p>假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多 线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完 成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作</p>
<h1 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier  和 CountDownLatch 的区别"></a>CyclicBarrier  和 CountDownLatch 的区别</h1><ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数 器，并让线程重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier 阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:18.286Z" title="2025/5/16 11:13:18">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">23 分钟读完 (大约3482个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc-%20%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%20%20AbstractQueuedSynchronizer%20%E7%9A%84%E5%AE%9E%E7%8E%B0%20/">AbstractQueuedSynchronizer 的实现</a></p><div class="content"><p>[TOC]</p>
<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>翻译过来是 AbstractQueuedSynchronizer ， 也是我们常说的 AQS 他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等都是基于 AQS 实现的。除此之外，我们还可以基于 AQS，定制出我们所需要的同步器。同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的 方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些 模板方法将会调用使用者重写的方法。</p>
<h1 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h1><p><img src="/zclvct.io/media/17332735927399/17332740833017.jpg"><br>6d7fb03256929308724c2416d09eaca5.png)</p>
<ul>
<li>state 表示同步器的状态 </li>
<li>head 和 tail 组成同步器 的 CLH（虚拟的双向队列）双向队列</li>
<li>ConditionObject 实现了 Condition （也称为条件队列或条件变量）  是每个对象具有了等待集 ， 如果锁取代了同步方法和语句的使用，则条件取代了对象监视器方法的使用。</li>
<li>unsafe  Java中的Unsafe类为我们提供了类似C++手动管理内存的能力。在AQS 执行CAS操作</li>
</ul>
<h2 id="重写同步器"><a href="#重写同步器" class="headerlink" title="重写同步器"></a>重写同步器</h2><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态</p>
<ul>
<li>getState()：获取当前同步状态。 </li>
<li>setState(int newState)：设置当前同步状态。 </li>
<li>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态 设置的原子性</li>
</ul>
<h2 id="同步器可重写的方法"><a href="#同步器可重写的方法" class="headerlink" title="同步器可重写的方法"></a>同步器可重写的方法</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>独占式获取同步状态，实现该方法需要查询当前状态并频段同步状态是否符合预期，然后再进行CAS设置同步状态</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td>protected int tryAcquireShared</td>
<td>共享式获取同步状态，返回大于等于 0 的值表示获取成功，反之获取失败</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>protected boolean isHeldExclusively()</td>
<td>但钱同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程锁独占</td>
</tr>
<tr>
<td>public final void acquire(int arg)</td>
<td>独占式获取同步状态，如果单线线程同步状态获取成功，则有该方法返回，否则进入同步队列等待</td>
</tr>
<tr>
<td>public final void acquireInterruptibly(int arg)</td>
<td>与acquire(int arg) 相同，但是该方法显影中断，当前线程为获取到同步状态二进入同步队列中，如果当前线程被中断，则该方法会判处InterruptedException并返回</td>
</tr>
<tr>
<td>public final boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>在 acquireInterruptibly 基础上增加了超市限制，如果当前线程在超市时间内没有获取到同步状态，那么会返回false，如果获取到了返回 true</td>
</tr>
<tr>
<td>public final void acquireShared(int arg)</td>
<td>共享式获取同步状态，如果当前线程为获取到同步状态，将会进入同步队列等待，与独占是获取的主要区别式在同一时刻可以又多个线程获取到同步状态</td>
</tr>
<tr>
<td>public final void acquireSharedInterruptibly(int arg)</td>
<td>与  acquireShared(int arg 相同，该方法响应中断</td>
</tr>
<tr>
<td>public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>在acquireSharedInterruptibly(int arg)基础上增加了超时限制</td>
</tr>
<tr>
<td>public final boolean release(int arg)</td>
<td>独占式 释放同步状态，该方法在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td>public final boolean releaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>public final Collection<Thread> getQueuedThreads()</td>
<td>获取等待在同步队列上的线程集合</td>
</tr>
</tbody></table>
<p>同步器提供的方法可以分为三大类</p>
<ul>
<li>独占式获取与释放同步状态、</li>
<li>共享式获取与释放</li>
<li>同步状态和查询同步队列中的等待线程情况</li>
</ul>
<h2 id="同步状态-state"><a href="#同步状态-state" class="headerlink" title="同步状态 state"></a>同步状态 state</h2><p>AQS 中的 state 是 volatile 修饰的 保证了字段可见性  使用 compareAndSetState 对 state进行操作 保证了原子性<br>AQS 获取、释放资源是否成功都是由state决定的</p>
<ul>
<li>ReentrantLock的state用来表示是否有锁资源</li>
<li>ReentrantReadWriteLock的state高16位代表读锁状态，低16位代表写锁状态</li>
<li>Semaphore的state用来表示可用信号的个数</li>
<li>CountDownLatch的state用来表示计数器的值</li>
</ul>
<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><h3 id="node节点"><a href="#node节点" class="headerlink" title="node节点"></a>node节点</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其 加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再 次尝试获取同步状态.<br>同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型与名称以及描述</p>
<p><img src="/zclvct.io/media/17332735927399/17332741107494.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 用于指示节点正在共享模式下等待的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">// 用于指示节点正在独占模式下等待的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示当前节点以取消调度（超时或者被中断） */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示后继节点处于等待状态 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示该节点在等待队列上，调用条件变量的 signal 方法 该节点会从等待队列转移到同步队列 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示下一次共享式同步状态获取将会无条件被传播下去*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">       <span class="comment">// 前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  		<span class="comment">// 后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 获取同步状态的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">       	<span class="comment">// 等待队列的后继节点</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同步队列结构"><a href="#同步队列结构" class="headerlink" title="同步队列结构"></a>同步队列结构</h3><p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转 而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式 与之前的尾节点建立关联。<br><img src="/zclvct.io/media/17332735927399/17332741287115.jpg"></p>
<h3 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h3><p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法 保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）<br>并通过addWaiter(Node node) 方法将该节点加入到同步队列的尾部，<br>最后调用acquireQueued(Node node,int arg)方法，使得该 节点以“死循环”的方式获取同步状态。<br>如果获取不到则阻塞节点中的线程，而被阻塞线程的 唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">		<span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        	<span class="comment">// 构建尾节点 以死循环的方式获取同步状态</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建 Node节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 判断尾节点 是不是空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 如果尾节点不等于null，把当前节点的前驱节点指向尾节点</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">// 替换尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果添加失败或队列不存在，执行end函数</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在enq(final Node node)方法中，<strong>同步器通过“死循环”来保证节点的正确添加</strong>，在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线 程不断地尝试设置。可以看出，enq(final Node node)方法将并发添加节点的请求通过CAS变 得“串行化”了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//循环</span></span><br><span class="line">            <span class="comment">//获取尾节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果尾节点为空，创建哨兵节点，通过cas把头节点指向哨兵节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    <span class="comment">//cas成功，尾节点指向哨兵节点</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当前节点的前驱节点设指向之前尾节点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//cas设置把尾节点指向当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    <span class="comment">//cas成功，之前尾节点的下个节点指向当前节点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，<strong>否则依旧留在这 个自旋过程中，并会阻塞节点的线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            	<span class="comment">// 获取前驱节点 </span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点是头节点 ， 获取同步状态</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                	<span class="comment">// 设置当前节点为头节点 也就是哨兵节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否需要挂起当前线程 主要是 判断是否为 Node.SIGNAL 状态， 如果是执行parkAndCheckInterrupt 调用线程的 park 阻塞线程</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                	<span class="comment">// 调用线程的 park 阻塞线程  线程在这里阻塞住 可能被唤醒 或者被打断 返回true 代表线程被打断</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 标记被打断</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">//如果出现异常或者出现中断，就会执行finally的取消线程的请求操作，核心代码是node.waitStatus = Node.CANCELLED;将线程的状态改为CANCELLED。</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>队列中各个节点的状态<br><img src="/zclvct.io/media/17332735927399/17332741550277.jpg"></p>
<p>独占式同步状态获取流程，也就是acquire(int arg)方法调用流程</p>
<p>前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状态是获取同步状态的自旋过程。当同步状态获取成功之后，当前线程从acquire(int arg)方法返回，如果 对于锁这种并发组件而言，代表着当前线程获取了锁。<br><img src="/zclvct.io/media/17332735927399/17332741685287.jpg"></p>
<h3 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h3><p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释 放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">		<span class="comment">// 释放同步状态</span></span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">           <span class="comment">// 头节点不为空 且 waitStatus 不等于零</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">           	<span class="comment">// 调用后继节点的 unpark</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        	<span class="comment">//unpark 唤醒线程</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h2><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。</p>
<p><strong>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的 特性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 到期时间    </span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="comment">// 进入队列尾部</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 判断获取同步状态 </span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算剩余时间 </span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">// park 当前线程 时间为剩余时间 </span></span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="comment">//  判断线程的打断状态 并清空打断状态    </span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/zclvct.io/media/17332735927399/17332741849881.jpg"></p>
<h2 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h2><p>共享式同步状态获取 与 独占锁的获取基本一直 差别就是共享式支持多个线程共享访问<br>在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg)方法返回值大于等于0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以<br>释放同步状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 唤醒后记节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:24.756Z" title="2025/5/16 11:13:24">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">26 分钟读完 (大约3904个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">synchronized 底层原理</a></p><div class="content"><p>[TOC]</p>
<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=281">来源</a><br>以32位虚拟机为例</p>
<p>普通对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params"> 							Object Header (64 bits)            </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|      <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)           |<span class="params">   Klass Word (32 bits)  </span>|</span><br><span class="line">|<span class="params">         （标记字段）                 </span>|         （类型指针）     |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------|<span class="params">-------------------------</span>|</span><br></pre></td></tr></table></figure>
<p>数组对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params"> 						Object Header (96 bits) 								  </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params"> Mark Word(32bits) 			 </span>| <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits)    |<span class="params"> array length(32bits)   </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure>
<p>其中Mark Word结构为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 						<span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)			    |<span class="params"> 		State        </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|     <span class="symbol">hashcode:</span><span class="number">25</span>     |<span class="params"> age:4  </span>|  <span class="symbol">biased_lock:</span><span class="number">0</span>  |<span class="params">  01  </span>| 		<span class="title class_">Normal</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:23 </span>| <span class="symbol">epoch:</span><span class="number">2</span> |<span class="params"> age:4  </span>| <span class="symbol">biased_lock:</span><span class="number">1</span>   |<span class="params"> 01   </span>|       <span class="title class_">Biased</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> 			ptr_to_lock_record:30                </span>| <span class="number">00</span>   |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 			<span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>        |<span class="params"> 10   </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> 												 </span>| <span class="number">11</span>   |<span class="params">   Marked <span class="keyword">for</span> GC    </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>
<p>64 位虚拟机 Mark Word</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 						<span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits) 					   |<span class="params"> 		State       </span>|</span><br><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params"> 01  </span>| 		<span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:54 </span>| <span class="symbol">epoch:</span><span class="number">2</span>     |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>| <span class="number">01</span>  |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 					<span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                    |<span class="params"> 00  </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">             ptr_to_heavyweight_monitor:62                  </span>| <span class="number">10</span>  |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                                  |<span class="params"> 11 </span>| <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure>

<h1 id="Monitor（锁）"><a href="#Monitor（锁）" class="headerlink" title="Monitor（锁）"></a>Monitor（锁）</h1><p>Monitor： 被翻译为 <strong>监视器</strong> 或<strong>管程</strong><br><img src="/zclvct.io/media/17332747791959/17332748211801.jpg"></p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2执行synchronized（obj）就会将Monitor 的所有者Owner置为Thread-2，Monitor中只能有一个Owner</li>
<li>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized（obj），就会进入EntryList BLOCKED</li>
<li>Thread-2执行完同步代码块的内容，然后唤醒 EntryList中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p><img src="/zclvct.io/media/17332747791959/17332947370901.jpg"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h5><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），可以用轻量级锁来优化</p>
<ul>
<li>轻量级锁对使用者还是透明的，语法仍然是synchronized</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)</span><br><span class="line">        &#123;<span class="comment">//同步块1</span></span><br><span class="line">         method2();&#125;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同步块2&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录结果，内部可以存储锁定对象的Mark Word（标记字段）<br><img src="/zclvct.io/media/17332747791959/17332748418721.jpg"></p>
</li>
<li><p>让锁对象中Object reference 指向，并尝试用cas替换Object的Mark Word，将Mark Word 的值存入锁记录<br><img src="/zclvct.io/media/17332747791959/17332748595317.png" alt="在这里插入图片描述"></p>
</li>
<li><p>如果cas替换成功，最想头存储了锁记录地址和状态 00 ，表示有该线程给对象加锁<br><img src="/zclvct.io/media/17332747791959/17332748595325.png" alt="在这里插入图片描述"></p>
</li>
<li><p>如果cas失败</p>
<ul>
<li><p>如果是其他线程已经持有该Object的轻量级锁，表明有竞争，进入锁膨胀过程</p>
</li>
<li><p>如果是同一线程执行了 &#x3D;&#x3D;synchronized 锁重入&#x3D;&#x3D; ，那么在天机一条Lock Record作为锁重入的计数<br>  <img src="/zclvct.io/media/17332747791959/17332748595335.png" alt="在这里插入图片描述"></p>
</li>
<li><p>当退出synchronized代码块时（解锁时），如果有取值位null的锁记录，表示有锁重入，只是重置锁记录，表示锁重入数减一</p>
</li>
</ul>
</li>
</ul>
<p><img src="/zclvct.io/media/17332747791959/17332748595348.png" alt="在这里插入图片描述"></p>
<pre><code>- 当退出synchronized代码块时（解锁时），锁记录部位null ，这时使用cas将 Mark World的值回复给对象头
    - 成功，则结果成功
    - 失败，说明轻量级锁进行了锁膨胀的过程或已经升级为重量级锁，进入重量级锁解锁流程
</code></pre>
<h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><ul>
<li>如果尝试加轻量级锁的过程中，CAS无法成功，这是有其他线程未次对象加上了轻量级锁（有竞争），这是需要进行所鹏展，将轻量级锁变成重量级锁。<ul>
<li><p>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁<br>  <img src="/zclvct.io/media/17332747791959/17332748595359.png" alt="在这里插入图片描述"></p>
</li>
<li><p>这是Thread-1加轻量级锁失败，进入做膨胀过程</p>
<ul>
<li>Object对象申请Monitor锁，让Object指向重量级锁的地址</li>
<li>然后自己进入Moniter的RntryList BOLOCED<br>  <img src="/zclvct.io/media/17332747791959/17332748596487.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，如果失败，这是会进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，是指Owner为null ，唤醒EntryList中的BLOCKED线程</p>
</li>
</ul>
</li>
</ul>
<h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，还可以用自旋来优化，如果当前线程自旋成功（即这时候持锁线程已经推出了同步块，释放了锁）这时当前线程可以避免阻塞进行上下文切换（上下文切换耗费性能）。<br><img src="/zclvct.io/media/17332747791959/17332748595371.png" alt="在这里插入图片描述"><br><img src="/zclvct.io/media/17332747791959/17332748595384.png" alt="在这里插入图片描述"></p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><ul>
<li>轻量级锁在没有竞争时，每次重入依然需要执行CAS操作</li>
<li>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
<li><img src="/zclvct.io/media/17332747791959/17332748595400.png" alt="在这里插入图片描述"></li>
</ul>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 						Mark <span class="title function_">Word</span> <span class="params">(<span class="number">64</span> bits)</span> 						| 		State	    |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 	unused:<span class="number">25</span> | hashcode:<span class="number">31</span> | unused:<span class="number">1</span> | age:<span class="number">4</span> | biased_lock:<span class="number">0</span> | <span class="number">01</span> | 		Normal      |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">|   thread:<span class="number">54</span> |  epoch:<span class="number">2</span>    | unused:<span class="number">1</span> | age:<span class="number">4</span> | biased_lock:<span class="number">1</span> | <span class="number">01</span> |       Biased      |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">|   				  ptr_to_lock_record:<span class="number">62</span>					   | <span class="number">00</span> |Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 					ptr_to_heavyweight_monitor:<span class="number">62</span>              | <span class="number">10</span> |Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 															   | <span class="number">11</span> |   Marked <span class="keyword">for</span> GC   |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br></pre></td></tr></table></figure>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<h4 id="锁撤销"><a href="#锁撤销" class="headerlink" title="锁撤销"></a>锁撤销</h4><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39568133/article/details/114757317">原文</a></p>
<ul>
<li><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销，在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</p>
<ul>
<li>偏向锁不会记录hashcode</li>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
</li>
<li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</li>
<li><p>wait&#x2F;notify 时重量级锁使用的方法 ，调用时偏向锁升级为重量级锁</p>
</li>
</ul>
<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><blockquote>
<p>以class为单位，为每个class维护一个偏向锁撤销计数器。每一次该class的对象发生偏向撤销操作是，该计数器+1，当这个值达到重偏向阈值(默认20)时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象也会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的站，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获取锁时，发现当前对象的epoch值和class不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id改为当前线程ID</p>
</blockquote>
<ul>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</li>
<li>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</li>
</ul>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><ul>
<li>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><ul>
<li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享 数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持</li>
</ul>
<h3 id="wait-notify-原理"><a href="#wait-notify-原理" class="headerlink" title="wait notify 原理"></a>wait notify 原理</h3><p><img src="/zclvct.io/media/17332747791959/17332748595419.png" alt="在这里插入图片描述"></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</span><br><span class="line">obj.wait()<span class="comment">// 让进入 object 监视器的线程到 waitSet 等待</span></span><br><span class="line">wait(<span class="type">long</span> n) <span class="comment">//有时限的等待, 到 n 毫秒后结束等待，或是被 notify</span></span><br><span class="line">obj.notify() <span class="comment">//在 object 上正在 waitSet 等待的线程中挑一个唤醒</span></span><br><span class="line">obj.notifyAll() <span class="comment">//让 object 上正在 waitSet 等待的线程全部唤醒</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="comment">// 主线程两秒后执行</span></span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">       log.debug(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">           obj.notify(); <span class="comment">// 唤醒obj上一个线程</span></span><br><span class="line">           <span class="comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">04</span> [Thread-<span class="number">3</span>] c.Test1 - 执行....</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">04</span> [Thread-<span class="number">4</span>] c.Test1 - 执行....</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">06</span> [main] c.Test1 - 唤醒 obj 上其它线程</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">06</span> [Thread-<span class="number">3</span>] c.Test1 - 其它代码....</span><br></pre></td></tr></table></figure>

<h3 id="wait-notify-的正确姿势"><a href="#wait-notify-的正确姿势" class="headerlink" title="wait notify 的正确姿势"></a>wait notify 的正确姿势</h3><h4 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a>sleep(long n) 和 wait(long n) 的区别</h4><ol>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>
<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们状态 TIMED_WAITING</li>
</ol>
<h3 id="保护式暂停模式"><a href="#保护式暂停模式" class="headerlink" title="保护式暂停模式"></a>保护式暂停模式</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式<br><img src="/zclvct.io/media/17332747791959/17332748595435.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">	 <span class="keyword">private</span> Object response;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	 <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Long timeOut)</span> &#123;  <span class="comment">//超时时间</span></span><br><span class="line">		 <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		<span class="comment">// 条件不满足则等待</span></span><br><span class="line">			<span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;   <span class="comment">//防止虚假唤醒</span></span><br><span class="line">				<span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeOut - timePassed;  <span class="comment">//计算剩余等待的时间</span></span><br><span class="line">				<span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					lock.wait(waitTime);   <span class="comment">//防止虚假唤醒后 等待时间大于输入时间</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 3) 记录已经经历的时间</span></span><br><span class="line">				timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> response;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">			<span class="built_in">this</span>.response = response;</span><br><span class="line">			lock.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 子线程执行下载</span></span><br><span class="line">           List&lt;String&gt; response = download();</span><br><span class="line">           log.debug(<span class="string">&quot;download complete...&quot;</span>);</span><br><span class="line">           guardedObject.complete(response);</span><br><span class="line">       &#125;).start();</span><br><span class="line">       log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">       <span class="comment">// 主线程阻塞等待</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObject.get();</span><br><span class="line">       log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">15</span> [main] c.Test1 - waiting...</span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">17</span> [Thread-<span class="number">3</span>] c.Test1 - download complete...</span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">17</span> [main] c.Test1 - get response: [<span class="number">2</span>] lines</span><br></pre></td></tr></table></figure>
<h3 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h3><p>利用了&#x3D;&#x3D;保护式暂停模式&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">totalWaited</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> <span class="variable">totalWaited</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录共计等待时间</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">toWait</span> <span class="operator">=</span> timeoutInMilliseconds;  <span class="comment">//记录约定等待时间</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">//记录是否超时</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeoutInMilliseconds == <span class="number">0</span> &amp; nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// We either round up (1 millisecond) or down (no need to wait, just return)</span></span><br><span class="line">		<span class="keyword">if</span> (nanos &lt; <span class="number">500000</span>)</span><br><span class="line">			timedOut = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			toWait = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!timedOut &amp;&amp; !isDead()) &#123; <span class="comment">//防止虚假环境，并且判断是否超时</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//记录等待开始时间</span></span><br><span class="line">		wait(toWait);     <span class="comment">// 开始等待 第一次等待时间为约定等待时间  第二次为剩余等待时间</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">waited</span> <span class="operator">=</span> System.currentTimeMillis() - start; <span class="comment">//计算本次循环等待时间</span></span><br><span class="line">		totalWaited+= waited;  <span class="comment">//计算共计等待时间</span></span><br><span class="line">		toWait -= waited;   <span class="comment">//计算等待时间</span></span><br><span class="line">		<span class="comment">// Anyone could do a synchronized/notify on this thread, so if we wait</span></span><br><span class="line">		<span class="comment">// less than the timeout, we must check if the thread really died</span></span><br><span class="line">		timedOut = (totalWaited &gt;= timeoutInMilliseconds);  <span class="comment">//超时判断</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/zclvct.io/media/17332747791959/17332748595454.jpg" alt="在这里插入图片描述"></p>
<h3 id="park-Unpark-（搁置、推迟）"><a href="#park-Unpark-（搁置、推迟）" class="headerlink" title="park &amp; Unpark   （搁置、推迟）"></a>park &amp; Unpark   （搁置、推迟）</h3><p>它们是 LockSupport 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">            LockSupport.park();    <span class="comment">//线程进行WAIT状态</span></span><br><span class="line">            log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p>与 Object 的 wait &amp; notify 相比</p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li>
<li>&#x3D;&#x3D;park &amp; unpark 可以先 unpark&#x3D;&#x3D;，而 wait &amp; notify 不能先 notify</li>
</ul>
<h4 id="park-unpark-原理"><a href="#park-unpark-原理" class="headerlink" title="park unpark 原理"></a>park unpark 原理</h4><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter（计算器） ， _cond（状态） 和 _mutex （互斥锁）<br><img src="/zclvct.io/media/17332747791959/17332748595469.png" alt="在这里插入图片描述"></p>
<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li>
<li>线程进入 _cond 条件变量阻塞</li>
<li>设置 _counter &#x3D; 0</li>
</ol>
<p><img src="/zclvct.io/media/17332747791959/17332748595489.png" alt="在这里插入图片描述"><br>5. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1<br>6. 唤醒 _cond 条件变量中的 Thread_0<br>7. Thread_0 恢复运行<br>8. 设置 _counter 为 0<br><img src="/zclvct.io/media/17332747791959/17332748595510.png" alt="在这里插入图片描述"><br> 9. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1<br>10. 当前线程调用 Unsafe.park() 方法<br>11. 检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行<br>12. 设置 _counter 为 0</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:57.218Z" title="2025/5/16 11:12:57">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">10 分钟读完 (大约1516个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B9%8Bvolatile/">共享内存之volatile</a></p><div class="content"><p>[TOC]</p>
<h1 id="并发编程三大性质"><a href="#并发编程三大性质" class="headerlink" title="并发编程三大性质"></a>并发编程三大性质</h1><ul>
<li>原子性：保证指令不会受到线程上下文切换影响</li>
<li>可见性：保证指令不会受cpu缓存影响</li>
<li>有序性：保证指令不会受cpu指令并行优化的影响</li>
</ul>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
<ul>
<li>volatile关键字 （易变）</li>
</ul>
<p>可以用来修饰成员变量和竞态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须要主存中获取他的值，线程造作volatile变量都是直接操作主存</p>
<ul>
<li>synchronized 加锁也可以保证可见性</li>
</ul>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。</p>
<ul>
<li>volatile 关键字修饰变量可以避免指令重排序</li>
</ul>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>volatile的底层实现原理是内存屏障，Memory Barrier （Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令&#x3D;&#x3D;后&#x3D;&#x3D;会加入写屏障</li>
<li>对 volatile 变量的读指令&#x3D;&#x3D;前&#x3D;&#x3D;加入读屏障</li>
</ul>
<h2 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h2><ol>
<li>处理器缓存写回主存</li>
<li>一个处理器缓存写回主存时保证其他处理器缓存失效</li>
</ol>
<h2 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h2><ul>
<li>写屏障（sfence）保证了的在该屏障之前的，对共享变量的变动，都同步到主存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span> <span class="params">( I_Result r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span> ; <span class="comment">//ready 是 volatile 赋值并带写屏障</span></span><br><span class="line">        <span class="comment">//写屏障    在写屏障之前的num 和 ready 都同步到主存中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的主存中最新的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span> <span class="params">( I_Result r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读屏障</span></span><br><span class="line">        <span class="keyword">if</span>(ready)   <span class="comment">//ready 是 volatile 读取值并带读屏障</span></span><br><span class="line">        &#123;</span><br><span class="line">            r.r1= num + num;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，写屏障保证了 写之前所有共享变量的可见性，读屏障保证了读之后所有变量的可见性<br><img src="/zclvct.io/media/17332739938932/17332742200767.jpg"></p>
<h2 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h2><ul>
<li><p>写屏障会确保指令重排时，不会将写屏障之前的代码排在写屏障之后<br><img src="/zclvct.io/media/17332739938932/17332742329368.jpg"></p>
</li>
<li><p>读屏障会确保指令重排时，不会将读屏障之后的代码排在读屏障之前<br><img src="/zclvct.io/media/17332739938932/17332742452020.jpg"></p>
</li>
</ul>
<p><img src="/zclvct.io/media/17332739938932/17332742613456.jpg"></p>
<h1 id="DCL-问题-double-checked-locking-问题"><a href="#DCL-问题-double-checked-locking-问题" class="headerlink" title="DCL  问题 double-checked locking 问题"></a>DCL  问题 double-checked locking 问题</h1><p>double-checked locking单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANSE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANSE == <span class="literal">null</span>) &#123;   <span class="comment">//无法保证 有序性 原子性 和 可见性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANSE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANSE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   <span class="comment">//这里 构造函数初始化 和 实例赋值 可能出现重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance时加锁 ，后续使用无需加锁</li>
<li>有隐含的。但很关键的一点：第一个if使用了INSTANSE 变量，是在同步块之外<br><img src="/zclvct.io/media/17332739938932/17332743110810.jpg"></li>
</ul>
<p>INSTANSE &#x3D; new Singleton(); 实际上不是原子操作  发生指令重排之后，第一步赋值 ，第二步调用构造方法，当他复制结束还没有调用构造方法时 ，另一个线程操作 if (INSTANSE &#x3D;&#x3D; null)  ，而此时这个操作在同步代码块之外，所以这是返回一个空的实例对象</p>
<p>&#x3D;&#x3D;这里可以利用 volatile 利用读写屏障保证指令重排&#x3D;&#x3D;</p>
<h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>happens-before 规定了对共享变量的写操作对其他线程的读操作可见，他是可见性与有序性的一套规则总结</p>
<ul>
<li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其他线程对改变量的读可见<br><img src="/zclvct.io/media/17332739938932/17332743241994.jpg"></p>
</li>
<li><p>线程对volatile 变量的写，对接下来其他线程对改变量的读可见<br><img src="/zclvct.io/media/17332739938932/17332743364507.jpg"></p>
</li>
<li><p>线程start之前对变量的写，对该线程开始后对该变量的读可见</p>
</li>
<li><p>线程结束前对该变量的写，对其他线程得知他结束后的读可见</p>
</li>
<li><p>线程t1打断线程t2前对变量的写，对于其他线程得知t2被打断后对变脸的读可见</p>
</li>
<li><p>对变量默认值的写，对其他线程对该变量的读可见</p>
</li>
<li><p>具有传递性<br><img src="/zclvct.io/media/17332739938932/17332743511507.jpg"></p>
</li>
</ul>
<h1 id="线程安全问题-单例模式"><a href="#线程安全问题-单例模式" class="headerlink" title="线程安全问题-单例模式"></a>线程安全问题-单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;   <span class="comment">//这里存在反序列化问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;  <span class="comment">//不能防止反射创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//类初始化时初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResovle</span><span class="params">()</span>&#123;  <span class="comment">//反序列化问题解决方式  JVM从内存中反序列化地&quot;组装&quot;一个新对象时,就会自动调用这个 </span></span><br><span class="line">    								<span class="comment">//readResolve方法来返回我们指定好的对象了, 单例规则也就得到了保证.</span></span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANSCE   <span class="comment">//不能用反射破环单例   可以避免反序列化破坏单例  属于饿汉式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;  <span class="comment">//每次加锁 浪费资源</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DCL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//防止指令重排序 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE== <span class="literal">null</span>) &#123;   </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;   <span class="comment">//防止 创建实例不是原子性引发的问题</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//静态内部类 静态的线程安全 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;  <span class="comment">//懒汉式  类加载时懒惰的 ，第一次使用时触发加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:04.390Z" title="2025/5/16 11:13:04">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/zclvct.io/categories/java/">java</a></span><span class="level-item">12 分钟读完 (大约1847个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/zclvct.io/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/">线程池中线程执行任务发生异常会怎么样</a></p><div class="content"><ol>
<li>线程池提交任务有两个方法<ul>
<li>submit</li>
<li>execute</li>
</ul>
</li>
</ol>
<h2 id="使用-execute-提交任务"><a href="#使用-execute-提交任务" class="headerlink" title="使用 execute 提交任务"></a>使用 execute 提交任务</h2><ol>
<li><p>测试代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">     <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">         <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">             <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">             thread.setName(<span class="string">&quot;threadFactory-&quot;</span>+index);</span><br><span class="line">             index.incrementAndGet();</span><br><span class="line">             <span class="keyword">return</span> thread;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(), threadFactory);</span><br><span class="line">	</span><br><span class="line">     threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName());</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">     threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName());</span><br><span class="line">     &#125;);</span><br><span class="line">	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">threadFactory-<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;threadFactory-1&quot;</span> java.lang.ArithmeticException: 除以零</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest.lambda$main$<span class="number">0</span>(ThreadPollTest.java:<span class="number">28</span>)</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest$$Lambda$<span class="number">1</span>/00000000037A8980.run(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">823</span>)</span><br><span class="line">threadFactory-<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分析结果<br> 在执行中结果中也可看出，execute执行方式抛出异常显示在控制台了 ，并且再次提交任务，发现是另一个线程去执行的任务</p>
</li>
<li><p>源码分析<br> 在线程中提交任务是把任务包装成 worker 对象， 调用 runWorker 来执行，一下是 runWorker 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们只看这里的主要部分<br>    1. beforeExecute(wt, task); 执行调用前的钩子方法<br>    2.  task.run(); 执行任务<br>    3.  afterExecute(task, thrown); 执行调用后的钩子方法<br>    4. processWorkerExit(w, completedAbruptly);<br>其中  afterExecute(task, thrown); 在 finally 代码块中 ，并且 传递了任务本身和异常信息，可以在发生异常时提供业务补偿的方式<br>同时 <strong>从代码中可以看出 虽然 catch 到异常了 但是没有处理 而是直接抛出</strong>。<br>在最外层调用了<strong>processWorkerExit(w, completedAbruptly);</strong><br>来看一下这个方法中做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">	        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">	            decrementWorkerCount();</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">	        mainLock.lock();</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            completedTaskCount += w.completedTasks;</span><br><span class="line">	            workers.remove(w);</span><br><span class="line">	        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	            mainLock.unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        tryTerminate();</span><br><span class="line">	</span><br><span class="line">	        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">	        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">	                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">	                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">	                    min = <span class="number">1</span>;</span><br><span class="line">	                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">	                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">	            &#125;</span><br><span class="line">	            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>
<p>processWorkerExit 方法有两个参数，第一个参数是执行的 worker 对象， 第二个参数 代表 执行过程中是否发生了异常<br>执行步骤</p>
<ol>
<li>判断是否是意外退出的，如果是意外退出的话，那么就需要把WorkerCount–</li>
<li>加完锁后，将completedTaskCount，表示总共完成的任务数，并且从WorkerSet中将对应的Worker移除 </li>
<li>判断当前的线程池状态，是否终止线程池</li>
<li>判断线程池的状态是否小于STOP，也就是处于RUNNING或者SHUTDOWN状态，如果不是不执行</li>
<li>上一步判断返回true 则判断线程是否抛出异常<br>  1）如果allowCoreThreadTimeOut&#x3D;true且队列不为空，那么需要至少保证有一个线程<br>  2）如果allowCoreThreadTimeOut&#x3D;false,那么需要保证线程数大于等于corePoolSize</li>
<li>如果线程抛出异常 放一个空的 worker 尝试新建一个线程</li>
</ol>
<h2 id="使用-execute-提交任务总结"><a href="#使用-execute-提交任务总结" class="headerlink" title="使用 execute 提交任务总结"></a>使用 execute 提交任务总结</h2><p>execute 提交任务时，当执行发生异常，那么会直接抛出异常，并且移除异常线程也就是 worker ，并且尝试放入一个新的线程</p>
<h2 id="使用-submit-提交任务"><a href="#使用-submit-提交任务" class="headerlink" title="使用 submit 提交任务"></a>使用 submit 提交任务</h2><ol>
<li><p>测试代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">       <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">           <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">               <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">               thread.setName(<span class="string">&quot;threadFactory-&quot;</span>+index);</span><br><span class="line">               index.incrementAndGet();</span><br><span class="line">               <span class="keyword">return</span> thread;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(), threadFactory);</span><br><span class="line">	</span><br><span class="line">       Future&lt;Object&gt; future = (Future&lt;Object&gt;) threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">           <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">	</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">       &#125;);</span><br><span class="line">       future.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行结果</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadFactory-<span class="number">1</span></span><br><span class="line">threadFactory-<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: java.lang.ArithmeticException: 除以零</span><br><span class="line">	at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">192</span>)</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest.main(ThreadPollTest.java:<span class="number">35</span>)</span><br><span class="line">Caused by: java.lang.ArithmeticException: 除以零</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest.lambda$main$<span class="number">0</span>(ThreadPollTest.java:<span class="number">28</span>)</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest$$Lambda$<span class="number">1</span>/000000000432EA90.run(Unknown Source)</span><br><span class="line">	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.run(FutureTask.java)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">823</span>)</span><br></pre></td></tr></table></figure>
<p> 从运行结果上来看 使用submit提交的任务，发生异常 ，不会立刻抛出异常，而是当 调用future.get();时发生异常，同时执行异常的线程没有被抛弃</p>
</li>
<li><p>源码分析<br> submit 提交的任务 实际上是调用FutureTask类的run方法如下： 这里他能提交 Runable 还有 Callable也是使用了适配器模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="type">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="literal">null</span>;</span><br><span class="line">                    ran = <span class="literal">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 从以上代码执行中我们可以看出  result &#x3D; c.call(); 被包裹在 try 代码块中，并且这里并没有和 runWorker 一样 经过异常抛出，而是在发生异常是调用了  setException(ex);  方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = t;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 	setException 中 把异常信息保存了下来 ，并通过cas 操作 FutureTask 的状态为异常状态<br>当调用get方法时，查看是异常状态则抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">     <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">         <span class="keyword">return</span> (V)x;</span><br><span class="line">     <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-submit-提交任务-总结"><a href="#使用-submit-提交任务-总结" class="headerlink" title="使用 submit 提交任务 总结"></a>使用 submit 提交任务 总结</h2><p>使用 submit 提交任务 发生异常不会直接抛出，也不会移除当前执行异常的线程，而是将异常保存在 FutureTask中，当调用get时抛出异常。</p>
<h1 id="setUncaughtExceptionHandler-方法详解"><a href="#setUncaughtExceptionHandler-方法详解" class="headerlink" title="setUncaughtExceptionHandler 方法详解"></a>setUncaughtExceptionHandler 方法详解</h1><p>先对对象维护了 一个 	private volatile UncaughtExceptionHandler exceptionHandler; 异常处理器</p>
<p>thread 定义了 一个 uncaughtException方法 ，当线程执行出现异常的时候，相当于会回调 UncaughtExceptionHandler 接口，通过 getUncaughtExceptionHandler 方法查看当前线程是否设置了 UncaughtExceptionHandler。有就调用，由于线程在创建的时候都会属于一个 ThreadGroup，会尝试调用 ThreadGroup 的 UncaughtExceptionHandler，如果还是没有设置，那么会调用 getDefaultUncaughtExceptionHandler 获取全局默认的 UncaughtExceptionHandler。</p>
<blockquote>
<p>Interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception.<br>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.</p>
</blockquote>
<p>当线程由于未捕获的异常而突然终止时调用的处理程序接口。<br>当线程由于未捕获的异常而即将终止时，Java 虚拟机将使用 Thread.getUncaughtExceptionHandler() 查询线程的 UncaughtExceptionHandler 并将调用处理程序的 uncaughtException 方法，将线程和异常作为参数传递。 如果一个线程没有显式设置它的 UncaughtExceptionHandler，那么它的 ThreadGroup 对象充当它的 UncaughtExceptionHandler。 如果 ThreadGroup 对象对处理异常没有特殊要求，则可以将调用转发给默认的未捕获异常处理程序</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/zclvct.io/img/avatar.png" alt="zcct"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zcct</p><p class="is-size-6 is-block">zcct</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/zclvct.io/archives/"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/zclvct.io/categories/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/zclvct.io/tags/"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/zclvct" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/zclvct.io/2024/09/01/redis/GeoHash/">GeoHash</a></p><p class="categories"><a href="/zclvct.io/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/zclvct.io/2024/09/01/redis/HyperLogLog/">HyperLogLog</a></p><p class="categories"><a href="/zclvct.io/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/zclvct.io/2024/09/01/redis/Scan%E6%8C%87%E4%BB%A4/">Scan指令</a></p><p class="categories"><a href="/zclvct.io/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/zclvct.io/2024/09/01/redis/PubSub%20%E6%B6%88%E6%81%AF%E5%A4%9A%E6%92%AD%20(%E7%BC%BA%E7%82%B9%E5%A4%9A%E4%B8%8D%E8%A2%AB%E4%BD%BF%E7%94%A8)/">PubSub 消息多播</a></p><p class="categories"><a href="/zclvct.io/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/zclvct.io/2024/09/01/redis/codis%20%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/">codis 集群方案</a></p><p class="categories"><a href="/zclvct.io/categories/redis/">redis</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/zclvct.io/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">63</span></span></a></li><li><a class="level is-mobile" href="/zclvct.io/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/zclvct.io/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/zclvct.io/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/zclvct.io/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/zclvct.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/juc/"><span class="tag">juc</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/jvm/"><span class="tag">jvm</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/redis/"><span class="tag">redis</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/sql%E4%BC%98%E5%8C%96/"><span class="tag">sql优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"><span class="tag">事务处理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tag">内存模型</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7/"><span class="tag">架构安全性</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/zclvct.io/tags/%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F/"><span class="tag">透明多级分流系统</span><span class="tag">6</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/zclvct.io/"><img src="/zclvct.io/img/logo.svg" alt="ZCCT" height="28"></a><p class="is-size-7"><span>&copy; 2025 zcct</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/zclvct.io/js/column.js"></script><script src="/zclvct.io/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/zclvct.io/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/zclvct.io/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/zclvct.io/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/zclvct.io/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/zclvct.io/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>