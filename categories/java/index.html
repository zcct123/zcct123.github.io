<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: java - ZCCT</title><link rel="manifest" href="../../manifest.json"><meta name="application-name" content="ZCCT"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZCCT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ZCCT"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="ZCCT"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="zcct"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"ZCCT","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"zcct"},"publisher":{"@type":"Organization","name":"ZCCT","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="../../img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../index.html"><img src="../../img/logo.svg" alt="ZCCT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../index.html">主页</a><a class="navbar-item" href="../../archives">档案</a><a class="navbar-item" href="../../categories">分类</a><a class="navbar-item" href="../../tags">标签</a><a class="navbar-item" href="../../about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="../../categories/">分类</a></li><li class="is-active"><a href="#" aria-current="page">java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:22.828Z" title="2025/5/16 11:14:22">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">15 分钟读完 (大约2178个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/jvm/Java%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F/">Java模块化系统</a></p><div class="content"><p>[TOC]</p>
<p>在JDK 9中引入的Java模块化系统（Java Platform Module System，JPMS）是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做 出了相应的变动调整，才使模块化系统得以顺利地运作。JDK 9的模块不仅仅像之前的JAR包那样只是简单地充当代码的容器，除了代码外，Java的模块定义还包含以下内容：</p>
<ul>
<li>依赖其他模块的列表。</li>
<li>导出的包列表，即其他模块可以使用的列表。</li>
<li>开放的包列表，即其他模块可反射访问模块的列表。</li>
<li>使用的服务列表。</li>
<li>提供服务的实现列表。</li>
</ul>
<p>可配置的封装隔离机制首先要解决JDK9之前基于类路径（ClassPath）来查找依赖的可靠性问题。<strong>此前，如果类路径中缺失了运行时依赖的类型，那就只能等程序运行到发生该类型的加载、链接 时才会报出运行的异常</strong>。<strong>而在JDK 9以后，如果启用了模块化进行封装，模块就可以声明对其他模块的显式依赖，这样Java虚拟机就能够在启动时验证应用程序开发阶段设定好的依赖关系在运行期是否完备，如有缺失那就直接启动失败，从而避免了很大一部分由于类型依赖而引发的运行时异常</strong>。</p>
<p>可配置的封装隔离机制还解决了原来类路径上跨JAR文件的public类型的可访问性问题。JDK9中的 ublic类型不再意味着程序的所有地方的代码都可以随意访问到它们，模块提供了更精细的可访问性控制，必须明确声明其中哪一些public的类型可以被其他哪一些模块访问，这种访问控制也主要是在类载过程中完成的。</p>
<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>Java 9 引入的模块化系统（Module System）主要解决了以下几个关键问题：</p>
<ol>
<li>类路径地狱（ClassPath Hell）</li>
</ol>
<p>在传统的 Java 应用程序中，类路径（ClassPath）管理非常复杂，尤其是在大型项目中。类路径地狱指的是由于类路径配置不当导致的类加载问题，例如：</p>
<ul>
<li>重复的类：多个JAR文件中包含同名类，导致类加载冲突。</li>
<li>缺失的类：类路径中缺少必要的类文件，导致 ClassNotFoundException 或 NoClassDefFoundError。</li>
<li>版本冲突：不同库依赖于不同版本的相同类，导致兼容性问题。</li>
</ul>
<p>模块化系统通过明确声明模块之间的依赖关系，避免了这些问题。每个模块都有自己的命名空间，类加载器会根据模块声明的依赖关系来加载类，从而减少了类路径配置的复杂性和错误。</p>
<ol>
<li>更好的封装</li>
</ol>
<p>在传统的 Java 应用程序中，所有的公共类（public 类）都对其他类可见，这导致了封装的不足。模块化系统通过 module-info.java 文件提供了更强的封装机制：</p>
<pre><code>* 默认封装：模块内部的包默认对其他模块不可见，除非显式导出。
* 导出包：模块可以通过 exports 关键字导出特定的包，使其对其他模块可见。
* 开放包：模块可以通过 opens 关键字开放特定的包，允许其他模块通过反射访问这些包中的类。
</code></pre>
<p>这种封装机制提高了代码的安全性和可维护性，减少了不必要的依赖和潜在的副作用。</p>
<ol start="2">
<li>依赖管理</li>
</ol>
<p>模块化系统允许明确声明模块之间的依赖关系，通过 requires 关键字指定模块依赖的其他模块。这使得依赖管理更加清晰和可控：</p>
<pre><code>* 显式依赖：模块必须显式声明其依赖的其他模块，避免了隐式依赖带来的问题。
* 版本管理：模块化系统支持版本管理，可以指定依赖的具体版本，减少版本冲突。
</code></pre>
<ol start="3">
<li>性能优化</li>
</ol>
<p>模块化系统通过以下方式优化了性能：</p>
<pre><code>* 按需加载：JVM 只加载应用程序实际使用的模块，减少了类加载的时间和内存占用。
* 模块缓存：JVM 可以缓存已加载的模块，加快后续启动时间。
* 类加载优化：模块化系统提供了更高效的类加载机制，减少了类加载的开销。
</code></pre>
<ol start="4">
<li>可维护性和可扩展性</li>
</ol>
<p>模块化系统使得大型应用程序的维护和扩展更加容易：<br>    * 独立开发：每个模块可以独立开发和测试，减少了模块间的耦合。<br>    * 模块替换：可以轻松地替换或升级单个模块，而不需要重新构建整个应用程序。<br>    * 模块隔离：模块之间的隔离机制减少了模块间的干扰，提高了系统的稳定性和可靠性。</p>
<ol start="5">
<li>标准化的平台模块</li>
</ol>
<p>Java 9 将 JDK 本身也模块化，将其拆分为多个标准模块，如 java.base、java.logging、java.sql 等。这使得开发者可以根据需要选择加载特定的模块，减少了 JDK 的体积和启动时间。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>模块路径：确保模块路径正确设置，否则 JVM 无法找到模块。</li>
<li>导出和开放：模块内部的包默认对其他模块不可见，需要显式导出或开放。</li>
<li>反射访问：模块化系统限制了反射访问，需要使用 –add-opens 或 –add-exports 参数来开放访问。</li>
</ul>
<h2 id="类加载器的变动"><a href="#类加载器的变动" class="headerlink" title="类加载器的变动"></a>类加载器的变动</h2><p>为了保证兼容性，JDK 9并没有从根本上动摇从JDK 1.2以来运行了二十年之久的三层类加载器架 构以及双亲委派模型。但是为了模块化系统的顺利施行，模块化下的类加载器仍然发生了一些应该被注意到变动，主要包括以下几个方面。</p>
<ol>
<li><p>扩展类加载器（Extension Class Loader）被平台类加载器（Platform Class Loader）取代。</p>
<p> 既然整个JDK都基于模块化进行构建（原来的rt.jar和tools.jar被拆分成数十个JMOD文件），其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留</p>
</li>
</ol>
<p><JAVA_HOM E>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了，用来加载这部分类库的扩展类加载器也完成了它的历史使命。</p>
<ol start="2">
<li><p>平台类加载器和应用程序类加载器都不再派生自java.net.URLClassLoader</p>
<p> 现在启动类加载器、平台类加载器、应用程序类加载器全都继承于</p>
</li>
</ol>
<p>jdk.internal.loader.BuiltinClassLoader，在BuiltinClassLoader中实现了新的模块化架构下类如何从模块中加载的逻辑，以及模块中资源可访问性的处理。</p>
<ol start="3">
<li>启动类加载器现在是在Java虚拟机 内部和Java类库共同协作实现的类加载器，尽管有了BootClassLoader这样的Java类，但为了与之前的代码保持兼容，所有在获取启动类加载器的场景（譬如Object.class.getClassLoader()）中仍然会返回null来代替，而不会得到BootClassLoader的实例。</li>
</ol>
<p><img src="media/17327806185618/17327814763235.jpg"></p>
<p>JDK9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了变动。<strong>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载</strong>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:13.946Z" title="2025/5/16 11:14:13">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">2 分钟读完 (大约346个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/jvm/%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98/">主内存与工作内存</a></p><div class="content"><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory ）中，每条线程还有自己的工作内存（Working Memory ），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图：</p>
<p><img src="media/17332080440323/17332080696248.jpg"></p>
<p>从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更基础的层次上说，主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:08.552Z" title="2025/5/16 11:14:08">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">10 分钟读完 (大约1549个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/jvm/%E6%B3%9B%E5%9E%8B/">泛型</a></p><div class="content"><p>[TOC]</p>
<p>泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Poly morphism）的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。</p>
<p>Java选择的泛型实现方式叫作“类型擦除式泛型”（Type Erasure Generics），而C#选择的泛型实现方式是“具现化式泛型”（Reified Generics）。具现化和特化、偏特化这些名词最初都是源于C++模版语法中的概念，C#里面泛型无论在程序源码里面、编译后的中间语言表示（Intermediate Language，这时候泛型是一个占位符）里面，抑或是运行期的CLR里面都是切实存在的，List<int>与 List<string>就是两个不同的类型，它们由系统在运行期生成，有着自己独立的虚方法表和类型数据。 而Java语言中的泛型则不同，它只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换 为原来的裸类型（Raw Type）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，Array ist<int>与ArrayList<String>其实是同一个类型，由此读者可以想象“类型擦除”这个名字的含义和来源。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TypeErasureGenerics&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public void doSomething(Object item) &#123;</span><br><span class="line">        if (item instanceof E) &#123;   // 不合法，无法对泛型进行实例判断</span><br><span class="line">             ...</span><br><span class="line">        &#125;</span><br><span class="line">        E newItem = new E();       // 不合法，无法使用泛型创建对象 E[]  </span><br><span class="line">        itemArray = new E[10]; // 不合法，无法使用泛型创建数组</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><p>要让所有需要泛型化的已有类型，譬如ArrayList，原地泛型化后变成了Array List<T>，而且保证以前直接用ArrayList的代码在泛型新版本里必须还能继续用这同一个容器，这就必须让所有泛型化的实例类型，譬如ArrayList<Integer>、Array List<String>这些全部自动成为ArrayList的子类型才能可以，否则类型转换就是不安全的。由此就引出了“裸类型”（Raw Type）的概 ，裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type），只有这样代码中的赋值才是被系统允许的从子类到父类的安全转型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; ilist = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">ArrayList&lt;String&gt; slist = new ArrayList&lt;String&gt;(); </span><br><span class="line">ArrayList list; // 裸类型</span><br><span class="line">list = ilist; </span><br><span class="line">list = slist;</span><br></pre></td></tr></table></figure>

<p><strong>泛型擦除前的例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); </span><br><span class="line">    map.put(&quot;hello&quot;, &quot;你好&quot;);</span><br><span class="line">    map.put(&quot;how are you?&quot;, &quot;吃了没？&quot;); </span><br><span class="line">    System.out.println(map.get(&quot;hello&quot;)); </span><br><span class="line">    System.out.println(map.get(&quot;how are you?&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了，程序又变回了Java泛型出现之前的写法，泛型类型都变回了裸类型，只在元素访问时插入了从Object到String的强制转型代码。</p>
<p><strong>泛型擦除后的例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Map map = new HashMap();</span><br><span class="line">    map.put(&quot;hello&quot;, &quot;你好&quot;);</span><br><span class="line">    map.put(&quot;how are you?&quot;, &quot;吃了没？&quot;);</span><br><span class="line">    System.out.println((String) map.get(&quot;hello&quot;)); </span><br><span class="line">    System.out.println((String) map.get(&quot;how are you?&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型擦除带来的缺陷"><a href="#类型擦除带来的缺陷" class="headerlink" title="类型擦除带来的缺陷"></a>类型擦除带来的缺陷</h2><ol>
<li><p>擦除法实现泛型直接导致了对原始类型（Primitive Types）无法支持泛型，因为一旦把泛型信息擦除后，到要插入强制转型代码的地方就没办法往下做了，因为不支持int、long与Object之间的强制转型。</p>
</li>
<li><p>运行期无法取到泛型类型信息。如下代码不得不加入的类型参数</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; T[] convert(List&lt;T&gt; list, Class&lt;T&gt; componentType) &#123;</span><br><span class="line">     T[] array = (T[])Array.newInstance(componentType, list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型遇见重载"><a href="#泛型遇见重载" class="headerlink" title="泛型遇见重载"></a>泛型遇见重载</h2><p>以下代码是不能被编译的，因为参数List<Integer>和List<String>编译之后都被擦除了，变成了同一种的裸类型List， 类型擦除导致这两个方法的特征签名变得一模一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class GenericTypes &#123;</span><br><span class="line">    public static void method(List&lt;String&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;invoke method(List&lt;String&gt; list)&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void method(List&lt;Integer&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;);</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>以下代码运行结果为：</p>
<p>invoke method(List<String> list)<br>invoke method(List<Integer> list)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class GenericTypes &#123;</span><br><span class="line">    public static String method(List&lt;String&gt; list) &#123; </span><br><span class="line">        System.out.println(&quot;invoke method(List&lt;String&gt; list)&quot;); </span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int method(List&lt;Integer&gt; list) &#123;</span><br><span class="line">        System.out.println(&quot;invoke method(List&lt;Integer&gt; list)&quot;);</span><br><span class="line">         return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        method(new ArrayList&lt;String&gt;()); </span><br><span class="line">        method(new ArrayList&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两段代码的差别是因为下面代码的两个method()方法添加了不同的返回值，由于这两个返 回值的加入，方法重载居然成功了，即这段代码可以被编译和执行了。之所以这次能编译和执行成功，是因为两个method()方法加入了不同的返回值后才能共存在一个Class文件之中，方法重载要求方法具备不同的特征签名，返回值并不包含在方法的特征签名中，所以返回值不参与重载选择，但是在Class文件格式之中，只要描述符不是完全一致的两个方法就可以共存。也就是说两个方法如果有相同的名称和特征签名，但返回值不同，那它们也是可以合法地共存于一个Class文件中的。</p>
<p>从上面的例子中可以看到擦除法对实际编码带来的不良影响，由于List<String>和List<Integer>擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载，这是一种毫无优 和美感可言的解决方案，并且存在一定语意上的混乱，必须用JDK6的Javac才能编译成功，其他版本或者是ECJ编译器都有可能拒绝编译。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:16.868Z" title="2025/5/16 11:14:16">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">2 分钟读完 (大约310个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/jvm/%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E6%8B%86%E7%AE%B1%E4%B8%8E%E9%81%8D%E5%8E%86%E5%BE%AA%E7%8E%AF/">自动装箱、拆箱与遍历循环</a></p><div class="content"><p>[TOC]</p>
<ol>
<li><p>自动装箱、拆箱与遍历循环</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4); </span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i : list) &#123; </span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>自动装箱、拆箱与遍历循环编译之后</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List list = Arrays.asList( new Integer[] &#123;</span><br><span class="line">            Integer.valueOf(1),</span><br><span class="line">            Integer.valueOf(2),</span><br><span class="line">            Integer.valueOf(3),</span><br><span class="line">            Integer.valueOf(4) &#125;);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (Iterator localIterator = list.iterator();  localIterator.hasNext(); ) &#123; </span><br><span class="line">            int i = ((Integer)localIterator.next()).intValue();</span><br><span class="line">            sum += i;</span><br><span class="line">         &#125;</span><br><span class="line">        System.out.println(sum); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>自动装箱、拆箱在编译之后被转化 成了对应的包装和还原方法，如本例中的Integer.valueOf()与Integer.intValue()方法，而遍历循环则是把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。最后再看看变长参数，它在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员的确也就是使用数组来完成类似功能的。</p>
<h2 id="自动装箱的陷阱"><a href="#自动装箱的陷阱" class="headerlink" title="自动装箱的陷阱"></a>自动装箱的陷阱</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer a = 1;</span><br><span class="line">    Integer b = 2; </span><br><span class="line">    Integer c = 3;</span><br><span class="line">    Integer d = 3;</span><br><span class="line">    Integer e = 321;</span><br><span class="line">    Integer f = 321;</span><br><span class="line">    Long g = 3L;</span><br><span class="line">    System.out.println(c == d); </span><br><span class="line">    System.out.println(e == f);</span><br><span class="line">    System.out.println(c == (a + b));</span><br><span class="line">    System.out.println(c.equals(a + b)); </span><br><span class="line">    System.out.println(g == (a + b));</span><br><span class="line">    System.out.println(g.equals(a + b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>true<br>false<br>true<br>true<br>true<br>false</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:11.284Z" title="2025/5/16 11:14:11">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">13 分钟读完 (大约1947个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84/">运行时栈帧结构</a></p><div class="content"><p>[TOC]</p>
<p>方法是Java虚拟机最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法调用和方法执行的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual M achine Stack）的栈元素。<strong>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息</strong>， 每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p>
<p><img src="media/17328477902466/17328480911148.jpg"></p>
<h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义 的局部变量。</p>
<p><strong>局部变量表的容量以变量槽（Variable Slot）为最小单位</strong>，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据。</p>
<p>一个变量槽可以存放一个 2位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、by te、char、short、int、 float、reference和returnAddress这8种类型。</p>
<blockquote>
<ul>
<li>reference类型表示对一个对象实例的引用，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则将无法实现《Java语言规范》中定义的语法约定。</li>
<li>returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了。</li>
</ul>
</blockquote>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。</p>
<p>当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。譬如<strong>在做算术运算的时候是通过将运算涉及的操作数栈压入栈顶后调用运算指令来进行的</strong>，又譬如<strong>在调用其他方法的时候是通过操作数栈来进行方法参数的传递</strong>。</p>
<p>两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调 用时就可以直接共用一部分数据，无须进行额外的参数复制传递了。</p>
<p><img src="media/17328477902466/17328616385625.jpg"></p>
<h2 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h2><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。这些符号 引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</p>
<h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><p>当一个方法开始执行后，只有两种方式退出这个方法</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”（Normal Method Invocation Completion）。</li>
<li>在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为“异常调用完成（Abrupt Method Invocation Completion）”。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者提供任何返回值的。</li>
</ol>
<p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能 续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。 一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。笔者这里写的“可能”是由于这是基于概念模型的讨论，只有具体到某一款Java虚拟机实现，会执行哪些操作才能确定下来。</p>
<h1 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h1><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:21.419Z" title="2025/5/16 11:13:21">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">14 分钟读完 (大约2157个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/ReentrantLock/">ReentrantLock</a></p><div class="content"><p>[TOC]</p>
<p>相对于 synchronized</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置公平锁 （防止饥饿）</li>
<li>支持多个条件变量 （类似于支持多个 waitSet）<br>与synchronized一样 ，都支持可重入</li>
</ul>
<p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">reentrantLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">       reentrantLock.lock();</span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//临界区</span></span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">         reentrantLock.unlock();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>可重入是指同一个线程如果首个获取了这把锁，那么因为他是这把锁的拥有者，因此有权利再次获取这把锁<br>如果不是可重入锁，那么第二次获取锁，自己也会被挡住</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       lock.lock();    <span class="comment">//lock加锁是不可打断的</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;main &quot;</span>);</span><br><span class="line">           m1();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;m1 &quot;</span>);</span><br><span class="line">           m2();</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           log.info(<span class="string">&quot;m2&quot;</span>);</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h3><p>被动的被打断 避免死等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 没有竞争获取锁</span></span><br><span class="line">            <span class="comment">//有竞争进入阻塞队列，可以被其他线程用 interruput 打断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;尝试获得锁&quot;</span>);</span><br><span class="line">                lock.lockInterruptibly();   <span class="comment">//可打断锁   防止无限制等待 ，可以防止死锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                log.info(<span class="string">&quot;没有获得锁，返回&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        t1.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;打断t1&quot;</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="comment">//if(!lock.tryLock())  //尝试获得锁  成功获得锁 失败不去阻塞队列等待   防止无限制等待</span></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(!lock.tryLock(<span class="number">2</span>,TimeUnit.SECONDS))   <span class="comment">//设置等待时间   也支持可打断的特性</span></span><br><span class="line">               &#123;</span><br><span class="line">                   log.info(<span class="string">&quot;获取不到锁&quot;</span>);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               log.info(<span class="string">&quot;没有获取锁，返回&quot;</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               log.info(<span class="string">&quot;获取到锁&quot;</span>);</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       lock.lock();</span><br><span class="line">       t1.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>RenntranLock 默认是不公平锁<br>公平锁 可以解决饥饿问题 ， 设置公平锁会降低并发度 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span>  构造函数传入是否是公平锁   </span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>synchronized 中也有条件变量，就是waitSet休息室，当条件不满足时进入waitSet等待</p>
<p>ReentranLock的条件变量比synchronized强大之处在于，支持多个条件变量</p>
<ul>
<li>synchronized 时那些不满足条件的线程都在一间休息室等消息</li>
<li>而ReentranLock支持多间休息室，可以分类</li>
</ul>
<p>使用流程</p>
<ul>
<li>await 前需要获取锁</li>
<li>await 执行后，会释放锁，静茹conditionObject等待</li>
<li>await 的线程被唤醒（或打断，超时）重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>  <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="comment">//创建一个姓的条件变量 （休息室）</span></span><br><span class="line">       <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">       <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="comment">//进入休息室等待</span></span><br><span class="line">       condition1.await();</span><br><span class="line">       condition1.signal();  <span class="comment">//唤醒等待的线程</span></span><br><span class="line">       condition2.signalAll(); <span class="comment">// 唤醒所有等待的线程</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步线程之顺序控制"><a href="#同步线程之顺序控制" class="headerlink" title="同步线程之顺序控制"></a>同步线程之顺序控制</h3><ol>
<li>使用synchrinized   wait（） notifyAll（）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">canRun</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!canRun)  <span class="comment">//防止虚假唤醒</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();  <span class="comment">// 不允许打印时 等待</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)</span><br><span class="line">        &#123;</span><br><span class="line">            log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            canRun = <span class="literal">true</span>; <span class="comment">//设置允许打印</span></span><br><span class="line">            lock.notifyAll(); <span class="comment">//唤醒所有等待线程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用RenntrinLock</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">   <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">   <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">canRun</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (!canRun &amp;&amp; lock.tryLock())  <span class="comment">//尝试获得锁 </span></span><br><span class="line">               &#123;</span><br><span class="line">                   condition.await();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">       &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">               canRun = <span class="literal">true</span>;</span><br><span class="line">               condition.signal();</span><br><span class="line">           &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">       thread1.start();</span><br><span class="line">       thread2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用park 和 unpark</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">canRun</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">while</span> (!canRun)</span><br><span class="line">          &#123;</span><br><span class="line">              LockSupport.park();</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">          log.info(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">          canRun = <span class="literal">true</span>;</span><br><span class="line">          LockSupport.unpark(thread1);</span><br><span class="line">      &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      thread1.start();</span><br><span class="line">      thread2.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步线程之交替输出"><a href="#同步线程之交替输出" class="headerlink" title="同步线程之交替输出"></a>同步线程之交替输出</h3><p>三个线程 t1输出 a t2输出 b t3输出c 让他们交替输出 abcabcabcabcabc 每个线程输出五次</p>
<ol>
<li>使用synchrinized   wait（） notifyAll（）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WaitNatify</span> <span class="variable">waitNatify</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNatify</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNatify.print(<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNatify.print(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            waitNatify.print(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitNatify</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WaitNatify</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">        <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str,<span class="type">int</span> waitFlag,<span class="type">int</span> nextFlag)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNum; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (flag != waitFlag)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="built_in">this</span>.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(str);</span><br><span class="line">                flag = nextFlag;</span><br><span class="line">                <span class="built_in">this</span>.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用ReentrinLock</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AwaitSignalAll</span> <span class="variable">awaitSignalAll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignalAll</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">a</span> <span class="operator">=</span> awaitSignalAll.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">b</span> <span class="operator">=</span> awaitSignalAll.newCondition();</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">c</span> <span class="operator">=</span> awaitSignalAll.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignalAll.print(<span class="string">&quot;a&quot;</span>, a,b);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignalAll.print(<span class="string">&quot;b&quot;</span>, b,c);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            awaitSignalAll.print(<span class="string">&quot;c&quot;</span>, c,a);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        awaitSignalAll.lock();  <span class="comment">// 这里不获得锁 引起java.lang.IllegalMonitorStateException异常 （非法监视器状态异常）</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            a.signalAll();  <span class="comment">//目前线程全部在休息室等待  ， 这里设置 第一次被唤醒的休息室的线程 </span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            awaitSignalAll.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignalAll</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AwaitSignalAll</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current,Condition next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNum; i++) &#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                current.await();  <span class="comment">//三个线程调用 全部进入自己的休息室等待</span></span><br><span class="line">                System.out.printf(str);   <span class="comment">//等待结束 打印str</span></span><br><span class="line">                next.signalAll();  <span class="comment">// 唤醒下一个应该执行的休息室内的线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用park 和 unpark</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> Thread thread1;</span><br><span class="line">    <span class="keyword">static</span> Thread thread2;</span><br><span class="line">    <span class="keyword">static</span> Thread thread3;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ParkUnpark</span> <span class="variable">parkUnpark</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line">        thread1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;a&quot;</span>, thread2);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;b&quot;</span>, thread3);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        thread3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            parkUnpark.print(<span class="string">&quot;c&quot;</span>, thread1);</span><br><span class="line">        &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">        LockSupport.unpark(thread1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> loopNum;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Thread next)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopNum; i++) &#123;</span><br><span class="line">            LockSupport.park();</span><br><span class="line">            System.out.printf(str);</span><br><span class="line">            LockSupport.unpark(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS   AbstractQueuedSynchronizer"></a>AQS   AbstractQueuedSynchronizer</h1><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p>
<ul>
<li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul>
<li>getState - 获取 state 状态</li>
<li>setState - 设置 state 状态</li>
<li>compareAndSetState - cas 机制设置 state 状态</li>
<li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li>
</ul>
</li>
<li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li>
<li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li>
</ul>
<p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException)</p>
<ul>
<li>tryAcquire           &#x2F;&#x2F;获取锁</li>
<li>tryRelease          &#x2F;&#x2F; 释放锁</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line"> <span class="comment">// 入队, 可以选择阻塞当前线程    实际用了 park unpark 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line"> <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不可重入锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Mylock</span> <span class="variable">mylock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mylock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            mylock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;枷锁成功&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mylock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            mylock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;枷锁成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                mylock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;解锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   自定义不可重入锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mylock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步器类   独占锁</span></span><br><span class="line">    <span class="keyword">class</span>  <span class="title class_">MySync</span>  <span class="keyword">extends</span> <span class="title class_">AbstractQueuedLongSynchronizer</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">long</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 加锁成功  设置线程位当前线程</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">long</span> arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);  <span class="comment">// state 是volatile 修饰，具有写屏障 保证之前的变量可见性</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span>  <span class="comment">//是否持有独占锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                <span class="comment">// 创建条件变量</span></span><br><span class="line">        <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">ConditionObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MySync</span>  <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">// 加锁   （不成功进入等待队列 ）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>      <span class="comment">// 可打断锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">// 可打断锁  尝试一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">//  尝试加锁 （带超时时间）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>,unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>       <span class="comment">//  创建条件变量</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ReentrinLock原理"><a href="#ReentrinLock原理" class="headerlink" title="ReentrinLock原理"></a>ReentrinLock原理</h1><p>构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();  <span class="comment">//  非公平锁</span></span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 加锁方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))   <span class="comment">// 改变 锁状态为加锁</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());  <span class="comment">//更改锁线程为当前线程</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               acquire(<span class="number">1</span>);   <span class="comment">// 加锁失败</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><img src="media/17332929193096/17332929468048.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">		<span class="comment">// 尝试加锁                  放入阻塞队列  addWaiter  （）</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>尝试加锁<br><img src="media/17332929193096/17332929468078.png" alt="在这里插入图片描述"><br>acquireQueued </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;    <span class="comment">// 死循环 尝试获得锁</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();   <span class="comment">//前驱节点   </span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;   <span class="comment">// 如果前驱节点是头节点  说明头节点是第二的 才有资格尝试获得锁</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;   <span class="comment">// 尝试获取锁失败</span></span><br><span class="line">                    parkAndCheckInterrupt())   <span class="comment">//阻塞 </span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="media/17332929193096/17332929468089.png" alt="在这里插入图片描述"><br>释放锁 </p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:07.867Z" title="2025/5/16 11:13:07">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">5 分钟读完 (大约738个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE/">java线程池的参数设置</a></p><div class="content"><h2 id="在说如何对线程池优化之前重复一下线程的7大参数"><a href="#在说如何对线程池优化之前重复一下线程的7大参数" class="headerlink" title="在说如何对线程池优化之前重复一下线程的7大参数"></a>在说如何对线程池优化之前重复一下线程的7大参数</h2><ul>
<li><p>corePoolSize： 核心线程数，也是线程池中常驻的线程数，线程池初始化时默认是没有线程的，当任务来临时才开始创建线程去执行任务</p>
</li>
<li><p>maximumPoolSize： 最大线程数，在核心线程数的基础上可能会额外增加一些非核心线程，需要注意的是只有当workQueue队列填满时才会创建多于corePoolSize的线程(线程池总线程数不超过maxPoolSize)</p>
</li>
<li><p>keepAliveTime： 非核心线程的空闲时间超过keepAliveTime就会被自动终止回收掉，注意当corePoolSize&#x3D;maxPoolSize时，keepAliveTime参数也就不起作用了(因为不存在非核心线程)；</p>
</li>
<li><p>unit： keepAliveTime的时间单位</p>
</li>
<li><p>workQueue： 用于保存任务的队列，可以为无界、有界、同步移交三种队列类型之一，当池子里的工作线程数大于corePoolSize时，这时新进来的任务会被放到队列中</p>
</li>
<li><p>threadFactory： 创建线程的工厂类，默认使用Executors.defaultThreadFactory()，也可以使用guava库的ThreadFactoryBuilder来创建</p>
</li>
<li><p>handler： 线程池无法继续接收任务(队列已满且线程数达到maximunPoolSize)时的饱和策略，取值有AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy</p>
</li>
</ul>
<h2 id="核心线程设置"><a href="#核心线程设置" class="headerlink" title="核心线程设置"></a>核心线程设置</h2><h3 id="计算密集型"><a href="#计算密集型" class="headerlink" title="计算密集型"></a>计算密集型</h3><p>当线程执行的是计算密集型的任务，那么要尽量防止线程的上下文切换，所以要设置的线程数要较少一点，一般设置为 <strong>线程数 &#x3D; CPU核数+1，也可以设置成CPU核数*2</strong></p>
<h3 id="I-0密集型"><a href="#I-0密集型" class="headerlink" title="I&#x2F;0密集型"></a>I&#x2F;0密集型</h3><p>在 WEB 应用中 涉及到大量的 i&#x2F;o传输 ， 一旦发生IO，线程就会处于等待状态，当IO结束，数据准备好后，线程才会继续执行。我们可以多设置一些线程池中线程的数量，这样就能让在等待IO的这段时间内，其他线程可以去做其它事，提高并发处理效率。对于IO密集型应用：<br><strong>线程数 &#x3D; CPU核心数&#x2F;(1-阻塞系数) 这个阻塞系数一般为0.8~0.9之间，也可以取0.8或者0.9</strong>。</p>
<h3 id="其他参数设置"><a href="#其他参数设置" class="headerlink" title="其他参数设置"></a>其他参数设置</h3><ol>
<li>根据不同的场景选择不同适合的拒绝策略 ， 也可以实现RejectedExecutionHandler接口自定义拒绝策略</li>
<li>使用线程工厂创建线程时正确的对线程命名，便于排查问题</li>
<li>我们也可以调用shutdown来手动终止线程池。如果我们忘记调用shutdown，为了让线程资源被释放，我们还可以使用keepAliveTime 和 allowCoreThreadTimeOut来达到目的</li>
<li>ThreadPoolExecutor提供了protected类型可以被覆盖的钩子方法，我们可以使用beforeExecute和afterExecute来记录线程之前前和后的一些运行情况</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:11.033Z" title="2025/5/16 11:13:11">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">16 分钟读完 (大约2470个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/java%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/">java线程运行原理</a></p><div class="content"><p>[TOC]</p>
<h3 id="基础解释"><a href="#基础解释" class="headerlink" title="基础解释"></a>基础解释</h3><p><strong>1.栈帧（存在于java栈）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      method1(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x + <span class="number">1</span>;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span>method2();</span><br><span class="line">      System.out.println(y);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>idea debug</strong><br><img src="media/17332745457143/17332745820135.jpg"></p>
<p><strong>图解</strong><br><img src="media/17332745457143/17332745982553.jpg"></p>
<h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><p><img src="media/17332745457143/17332746124588.jpg"></p>
<h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>因为以下一些原因导致CPU不再执行当前线程，转而执行另一个线程的代码 叫做上下文切换</p>
<p>原因</p>
<ul>
<li>线程的cpu时间片用完了</li>
<li>垃圾回收</li>
<li>优先级高的线程需要运行</li>
<li>&#x3D;&#x3D;主动：&#x3D;&#x3D;  线程自己调用了 sleep、yield、wait、join、park、synchronized、lock等方法</li>
</ul>
<p>当Context Switch发生时，需要保存当前线程的状态，并恢复另一个线程，对应jiava中的程序计数器（PC register），他的作用是记住下一条jvm指令地址</p>
<ul>
<li>频繁切换会影响性能</li>
</ul>
<h3 id="线程中常见方法"><a href="#线程中常见方法" class="headerlink" title="线程中常见方法"></a>线程中常见方法</h3><table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>start()</td>
<td></td>
<td>启动一个新线程，在新的线程运行 run 方法中的代码</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出IllegalThreadStateException</td>
</tr>
<tr>
<td>run()</td>
<td></td>
<td>新线程启动后会调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td>join()</td>
<td></td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>join(long n)</td>
<td></td>
<td>等待线程运行结束,最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>getId()</td>
<td></td>
<td>获取线程长整型的 id id 唯一</td>
<td></td>
</tr>
<tr>
<td>getName()</td>
<td></td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>setName(String)</td>
<td></td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>getPriority()</td>
<td></td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>setPriority(int)</td>
<td></td>
<td>修改线程优先级</td>
<td>java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>getState()</td>
<td></td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING,TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td>isInterrupted()</td>
<td></td>
<td>判断是否被打断， 不会清除 打断标记</td>
<td></td>
</tr>
<tr>
<td>isAlive()</td>
<td></td>
<td>线程是否存活（还没有运行完毕）</td>
<td></td>
</tr>
<tr>
<td>interrupt()</td>
<td></td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出 InterruptedException，&#x3D;&#x3D;并清除打断标记&#x3D;&#x3D; ；如果打断的正在运行的线程，则会设置&#x3D;&#x3D;打断标记&#x3D;&#x3D; ；park 的线程被打断，也会设置 &#x3D;&#x3D;打断标记&#x3D;&#x3D;</td>
</tr>
<tr>
<td>interrupted</td>
<td>static</td>
<td>判断当前线程是否被打断</td>
<td>会清除&#x3D;&#x3D;打断标记&#x3D;&#x3D;</td>
</tr>
<tr>
<td>currentThread()</td>
<td>static</td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td>sleep(long n)</td>
<td>static</td>
<td>让当前执行的线程休眠n毫秒休眠时让出 cpu 的时间片给其它线程</td>
<td></td>
</tr>
<tr>
<td>yield()</td>
<td>static</td>
<td>提示线程调度器让出当前线程对CPU的使用</td>
<td>主要是为了测试和调试</td>
</tr>
</tbody></table>
<h4 id="1-run-和-start"><a href="#1-run-和-start" class="headerlink" title="1. run 和 start"></a>1. run 和 start</h4><ul>
<li>重写run（）方法写的是线程需要执行的代码</li>
<li>start（）是前程启动的方法</li>
</ul>
<h4 id="2-sleep-与-yield（让步-放弃）"><a href="#2-sleep-与-yield（让步-放弃）" class="headerlink" title="2. sleep 与 yield（让步;放弃）"></a>2. sleep 与 yield（让步;放弃）</h4><p><strong>2.1 sleep</strong></p>
<ul>
<li>sleep  执行 线程由 Running 进入 Timed_Waiting（阻塞）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">       <span class="meta">@SneakyThrows</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">   thread.start();</span><br><span class="line">   Thread.sleep(<span class="number">500</span>);</span><br><span class="line">   System.out.println(<span class="string">&quot;线程的状态：&quot;</span>+thread.getState());</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程的状态：TIMED_WAITING</span><br></pre></td></tr></table></figure>
<ul>
<li>线程可以使用interrupt方法打断正在睡眠的线程，这时 sleep方法会抛出 InterruptedException异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;sleep....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;wake up ....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">&quot;interrupt....&quot;</span>);</span><br><span class="line">        thread.interrupt();  <span class="comment">//叫醒</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">19:46:22 [t1] c.Test1 - <span class="built_in">sleep</span>....</span><br><span class="line">19:46:23 [main] c.Test1 - interrupt....</span><br><span class="line">19:46:23 [t1] c.Test1 - wake up ....</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.lang.Thread.<span class="built_in">sleep</span>(Native Method)</span><br><span class="line">	at java.lang.Thread.<span class="built_in">sleep</span>(Thread.java:953)</span><br><span class="line">	at com.zclvct.juc.test.ThreadTest1<span class="variable">$1</span>.run(ThreadTest1.java:85)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:823)</span><br></pre></td></tr></table></figure>
<ul>
<li>睡眠结束后的线程未必立刻执行</li>
<li>建议用TimeUnit的类进行睡眠</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;sleep....&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                log.info(<span class="string">&quot;sleep end ....&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">19:52:11 [t1] c.Test1 - <span class="built_in">sleep</span>....</span><br><span class="line">19:52:13 [t1] c.Test1 - <span class="built_in">sleep</span> end ....</span><br></pre></td></tr></table></figure>

<p><strong>2.1 yield  （让出、谦让）</strong></p>
<ul>
<li>调用yield（）会让当前线程让当前线程从Running 进入 Runnable 状态 ，然后调度其他线程</li>
<li>具体实现依赖于操作系统的调度器。<br>&#x3D;&#x3D; 就绪状态（Runnable）会被调度器调度  而  阻塞状态（Timed_Waiting）不会&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(;;)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;======1 &quot;</span>+count++);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(;;)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">// Thread.yield();</span></span><br><span class="line">                System.out.println(<span class="string">&quot;=============2 &quot;</span>+count++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2);</span><br><span class="line">        thread1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        thread2.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过yeild（）或设置优先级 在一定条件下 count的差值会变大<br><strong>2.3 线程优先级</strong></p>
</li>
<li><p>setPriority（） getPriority（） </p>
</li>
<li><p>优先级会提示调度器优先调度的线程，当时调度器课以忽略他 ， 他仅仅是提示作用</p>
</li>
<li><p>如果cpu防盲，那么优先级高的线程会获取更多的时间片，但cpu闲时几乎没有作用</p>
</li>
</ul>
<h4 id="2-join"><a href="#2-join" class="headerlink" title="2. join"></a>2. join</h4><ul>
<li>等待调用的线程运行结束</li>
</ul>
<p><strong>1.join 同步应用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始。。。&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@SneakyThrows</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;开始。。。&quot;</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                log.info(<span class="string">&quot;结束。。。&quot;</span>);</span><br><span class="line">                i = <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;th1&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.join();</span><br><span class="line">        log.info(<span class="string">&quot;结果为：&#123;&#125;&quot;</span>,i);</span><br><span class="line">        log.info(<span class="string">&quot;结束。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">30</span> [main] c.Test1 - 开始。。。</span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">30</span> [th1] c.Test1 - 开始。。。</span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">31</span> [th1] c.Test1 - 结束。。。</span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">31</span> [main] c.Test1 - 结果为：<span class="number">10</span></span><br><span class="line"><span class="number">20</span>:<span class="number">27</span>:<span class="number">31</span> [main] c.Test1 - 结束。。。·</span><br></pre></td></tr></table></figure>
<p><img src="media/17332745457143/17332746349608.jpg"></p>
<p><strong>1.join 等待最大时间</strong></p>
<ul>
<li>thread.join（1000） 设置等待最大时间  ，到时间则结束不继续等待线程执行完毕</li>
</ul>
<h4 id="2-interrupt-（打断）"><a href="#2-interrupt-（打断）" class="headerlink" title="2. interrupt （打断）"></a>2. interrupt （打断）</h4><p> <strong>打断 sleep 、 wait 、 join的线程</strong></p>
<ul>
<li>打断sleep线程，&#x3D;&#x3D;会清空打断状态、会抛出异常&#x3D;&#x3D;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;sleep....&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);  <span class="comment">// wait ， join ,sleep 被打断会清除打断标记</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;wake up ....&quot;</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.info(<span class="string">&quot;interrupt....&quot;</span>);</span><br><span class="line">        thread1.interrupt();  <span class="comment">//打断</span></span><br><span class="line">        log.debug(<span class="string">&quot;打断标记 &#123;&#125;&quot;</span>,thread1.isInterrupted());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">00</span> [t1] c.Test1 - sleep....</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">01</span> [main] c.Test1 - interrupt....</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">01</span> [t1] c.Test1 - wake up ....</span><br><span class="line"><span class="number">20</span>:<span class="number">55</span>:<span class="number">01</span> [main] c.Test1 - 打断标记 <span class="literal">false</span></span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">	at java.lang.Thread.sleep(Native Method)</span><br><span class="line">	at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">	at com.zclvct.juc.test.ThreadTest1$<span class="number">1.</span>run(ThreadTest1.java:<span class="number">183</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">823</span>)</span><br></pre></td></tr></table></figure>
<p><strong>打断正常运行的线程线程</strong></p>
<ul>
<li>打断正常运行的线程线程  ，&#x3D;&#x3D;不会清空打断标记 ，不会抛出异常&#x3D;&#x3D; </li>
<li>isInterrupted（） 不会清除打断标记  static  interrupted （） 会清除打断标记 两者都是判断打断标记的放法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> Thread.currentThread().isInterrupted();</span><br><span class="line">                 <span class="keyword">if</span>(interrupted)</span><br><span class="line">                 &#123;</span><br><span class="line">                     log.info(<span class="string">&quot;被打断退出循环&quot;</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">     thread1.start();</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">     log.info(<span class="string">&quot;interrupt....&quot;</span>);</span><br><span class="line">     thread1.interrupt();  <span class="comment">//打断</span></span><br><span class="line">     log.debug(<span class="string">&quot;打断标记 &#123;&#125;&quot;</span>,thread1.isInterrupted());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">00</span>:<span class="number">54</span> [main] c.Test1 - interrupt....</span><br><span class="line"><span class="number">21</span>:<span class="number">00</span>:<span class="number">54</span> [t1] c.Test1 - 被打断退出循环</span><br><span class="line"><span class="number">21</span>:<span class="number">00</span>:<span class="number">54</span> [main] c.Test1 - 打断标记 <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p> <strong>两阶段终止模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Thread monitor; <span class="comment">//监控线程</span></span><br><span class="line">        <span class="comment">// 启动监控线程</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">            monitor = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> thread.isInterrupted();</span><br><span class="line">                    <span class="keyword">if</span>(interrupted)</span><br><span class="line">                    &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;打断我 ，我选择认输&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        log.info(<span class="string">&quot;执行监控功能&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;正在睡眠打断我，设置打断标记&quot;</span>);</span><br><span class="line">                        thread.interrupt();</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            monitor.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 停止监控线程</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">            monitor.interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="type">TwoPhaseTermination</span> <span class="variable">twoPhaseTermination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwoPhaseTermination</span>();</span><br><span class="line">       twoPhaseTermination.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">       twoPhaseTermination.stop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">20</span> [Thread-<span class="number">3</span>] c.Test1 - 执行监控功能</span><br><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">21</span> [Thread-<span class="number">3</span>] c.Test1 - 执行监控功能</span><br><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">22</span> [Thread-<span class="number">3</span>] c.Test1 - 正在睡眠打断我，设置打断标记</span><br><span class="line"><span class="number">21</span>:<span class="number">23</span>:<span class="number">22</span> [Thread-<span class="number">3</span>] c.Test1 - 打断我 ，我选择认输</span><br></pre></td></tr></table></figure>
<p><img src="media/17332745457143/17332746547474.jpg"></p>
<p><strong>打断park线程</strong></p>
<ul>
<li>打断park线程，不会清空打断状态</li>
<li>打断状态为真时再次park（）不会生效 可以利用 static interrupted清除打断状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;park。。&quot;</span>);</span><br><span class="line">                LockSupport.park(); </span><br><span class="line">                log.info(<span class="string">&quot;unpark....&quot;</span>);</span><br><span class="line">                log.info(<span class="string">&quot;打断状态 &#123;&#125;&quot;</span>,Thread.currentThread().isInterrupted());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;th1&quot;</span>);</span><br><span class="line">        th1.start();</span><br><span class="line">        th1.interrupt();</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">48</span> [th1] c.Test1 - park。。</span><br><span class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">48</span> [th1] c.Test1 - unpark....</span><br><span class="line"><span class="number">13</span>:<span class="number">21</span>:<span class="number">48</span> [th1] c.Test1 - 打断状态 <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p><strong>不推荐的方法</strong></p>
<ul>
<li>会破坏同步代码块，造成线程死锁<table>
<thead>
<tr>
<th>方法名</th>
<th>static</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>stop（）</td>
<td></td>
<td>停止线程运行</td>
</tr>
<tr>
<td>suspend（）</td>
<td></td>
<td>挂起（暂停）线程运行</td>
</tr>
<tr>
<td>resume（）</td>
<td></td>
<td>恢复线程运行</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h3><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即使守护线程的代码没有执行完，也会立即结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">th1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="keyword">if</span>(Thread.currentThread().isInterrupted())</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               log.info(Thread.currentThread().getName() +<span class="string">&quot; 运行结束&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;th1&quot;</span>);</span><br><span class="line">       th1.setDaemon(<span class="literal">true</span>);  <span class="comment">//设置线程为守护线程   </span></span><br><span class="line">       th1.start();</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">       log.info(<span class="string">&quot;主线程结束。。。&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>:<span class="number">44</span>:<span class="number">57</span> [main] c.Test1 - 主线程结束。。。</span><br></pre></td></tr></table></figure>
<ul>
<li>垃圾回收线程就是守护线程</li>
<li>Tomcat中的Acceptor 和 Poller线程都是守护线程</li>
</ul>
<h3 id="线程的五种状态-（操作系统层面）"><a href="#线程的五种状态-（操作系统层面）" class="headerlink" title="线程的五种状态 （操作系统层面）"></a>线程的五种状态 （操作系统层面）</h3><p><img src="media/17332745457143/17332746697734.jpg"></p>
<h3 id="线程的六种状态（java层面）"><a href="#线程的六种状态（java层面）" class="headerlink" title="线程的六种状态（java层面）"></a>线程的六种状态（java层面）</h3><p><img src="media/17332745457143/17332746919747.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123; <span class="comment">// runnable</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t3&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t4&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>); <span class="comment">// timed_waiting</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t5&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t2.join(); <span class="comment">// waiting</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t5.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t6&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (TestState.class) &#123; <span class="comment">// blocked    同一个对象加锁 他拿不到锁</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t6.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;t1 state &#123;&#125;&quot;</span>, t1.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t2 state &#123;&#125;&quot;</span>, t2.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t3 state &#123;&#125;&quot;</span>, t3.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t4 state &#123;&#125;&quot;</span>, t4.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t5 state &#123;&#125;&quot;</span>, t5.getState());</span><br><span class="line">        log.debug(<span class="string">&quot;t6 state &#123;&#125;&quot;</span>, t6.getState());</span><br><span class="line">        System.in.read();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">36</span> [t3] c.TestState - running...</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t1 state NEW</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t2 state RUNNABLE</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t3 state TERMINATED  terminated</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t4 state TIMED_WAITING</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t5 state WAITING</span><br><span class="line"><span class="number">14</span>:<span class="number">30</span>:<span class="number">37</span> [main] c.TestState - t6 state BLOCKED</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:14.722Z" title="2025/5/16 11:13:14">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">14 分钟读完 (大约2072个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%20%E4%B9%8B%20CyclicBarrier%E3%80%81CountDownLatch%E3%80%81Semaphore%E7%9A%84%E7%90%86%E8%A7%A3/">juc 之 CyclicBarrier、CountDownLatch、Semaphore的理解</a></p><div class="content"><p>[TOC]</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>在 jdk 的注释中 是这样描述他的</p>
<blockquote>
<p>一个计数信号灯。从概念上讲，信号量维护一组许可证。如有必要，每个采集模块都会阻塞，直到获得许可证，然后再获取许可证。每次发布都会添加一个许可证，可能会释放一个阻塞收单机构。然而，没有使用实际的许可证对象；信号量只是保持可用数量的计数，并相应地进行操作。<br><strong>信号量通常用于限制可以访问某些（物理或逻辑）资源的线程数。</strong></p>
</blockquote>
<h2 id="Semaphore的使用"><a href="#Semaphore的使用" class="headerlink" title="Semaphore的使用"></a>Semaphore的使用</h2><p>老规矩先看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">semaphoreTest</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 获得许可&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 释放许可&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660359070454</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 获得许可</span><br><span class="line"><span class="number">1660359070454</span>:pool-<span class="number">1</span>-thread-<span class="number">4</span>: 获得许可</span><br><span class="line"><span class="number">1660359070455</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 获得许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">4</span>: 释放许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 释放许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 释放许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 获得许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">6</span>: 获得许可</span><br><span class="line"><span class="number">1660359072456</span>:pool-<span class="number">1</span>-thread-<span class="number">5</span>: 获得许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">6</span>: 释放许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">8</span>: 获得许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">7</span>: 获得许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">5</span>: 释放许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 释放许可</span><br><span class="line"><span class="number">1660359074466</span>:pool-<span class="number">1</span>-thread-<span class="number">9</span>: 获得许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">8</span>: 释放许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">10</span>: 获得许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">7</span>: 释放许可</span><br><span class="line"><span class="number">1660359076470</span>:pool-<span class="number">1</span>-thread-<span class="number">9</span>: 释放许可</span><br><span class="line"><span class="number">1660359078472</span>:pool-<span class="number">1</span>-thread-<span class="number">10</span>: 释放许可</span><br></pre></td></tr></table></figure>
<p>从上边的代码中可以看出<br>信号量通常用于限制可以访问某些（物理或逻辑）资源的线程数。在上面的代码中可以看出 最多运行的资源数只有三个</p>
<h2 id="Semaphore-应用场景"><a href="#Semaphore-应用场景" class="headerlink" title="Semaphore 应用场景"></a>Semaphore 应用场景</h2><p>Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假 如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程 并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这 时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连 接。这个时候，就可以使用Semaphore来做流量控制，</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>在 jdk 的注释中 是这样描述他的</p>
<blockquote>
<p>一种同步辅助工具，允许一组线程都等待对方到达一个公共障碍点。CyclicBarrier在涉及固定大小的线程组的程序中很有用，这些线程偶尔必须相互等待。该屏障被称为循环屏障，因为它可以在等待线程释放后重新使用。</p>
<p>它要做的事情就是让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行</p>
</blockquote>
<p>但在使用中需要注意的是 线程的数量 和  CyclicBarrier 构造函数中 parties 的数量要保持一直，以为他只维护了一个计数器，如果说线程数量是 4 CyclicBarrier 构造函数 的数量是三，那个 第四个线程执行时 会一直 Await，同样 如果 Await 三次 4个线程同样可以执行完成，但是这样就无法保证不同线程 是否到达 同一个 障碍点。</p>
<h2 id="CyclicBarrier-的使用"><a href="#CyclicBarrier-的使用" class="headerlink" title="CyclicBarrier 的使用"></a>CyclicBarrier 的使用</h2><p> 这里设置 三个线程数 同时  CyclicBarrier 允许的一组线程数为三</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">cyclicBarrierTest</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 正在准备&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 正在执行&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 执行完成&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660362890906</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在准备</span><br><span class="line"><span class="number">1660362890906</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在准备</span><br><span class="line"><span class="number">1660362890906</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在准备</span><br><span class="line"><span class="number">1660362892916</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在执行</span><br><span class="line"><span class="number">1660362892916</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在执行</span><br><span class="line"><span class="number">1660362892916</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在执行</span><br><span class="line"><span class="number">1660362894925</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 执行完成</span><br><span class="line"><span class="number">1660362894925</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 执行完成</span><br><span class="line"><span class="number">1660362894925</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 执行完成</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出 必须有足够 3 的线程到达障碍点 才能继续向下执行 ， 同时他可以设置多个障碍点</p>
<p>** CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrier- Action），用于在线程到达屏障时，优先执行barrierAction**<br>在 barrierAction 中打印 优先执行了 A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">cyclicBarrierTest01</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 优先执行了 A&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 正在准备&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 正在执行&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">&quot;:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: 执行完成&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660363624132</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在准备</span><br><span class="line"><span class="number">1660363624132</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在准备</span><br><span class="line"><span class="number">1660363624132</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在准备</span><br><span class="line"><span class="number">1660363626142</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 优先执行了 A</span><br><span class="line"><span class="number">1660363626143</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 正在执行</span><br><span class="line"><span class="number">1660363626143</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 正在执行</span><br><span class="line"><span class="number">1660363626143</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 正在执行</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 优先执行了 A</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 执行完成</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 执行完成</span><br><span class="line"><span class="number">1660363628149</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 执行完成</span><br></pre></td></tr></table></figure>

<h2 id="CyclicBarrier-应用场景"><a href="#CyclicBarrier-应用场景" class="headerlink" title="CyclicBarrier 应用场景"></a>CyclicBarrier 应用场景</h2><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。例如，用一个Excel保 存了用户所有银行流水，每个Sheet保存一个账户近一年的每笔银行流水，现在需要统计用户 的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日 均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水，</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<blockquote>
<p>一种同步辅助工具，允许一个或多个线程等待，直到在其他线程中执行的一组操作完成。使用给定计数初始化倒计时锁存器。由于调用倒计时方法，等待方法一直阻塞，直到当前计数达到零，然后释放所有等待线程，并立即返回任何后续的等待调用。<strong>这是一种一次性现象——计数无法重置。如果需要重置计数的版本，请考虑使用CyclicBarrier</strong>。</p>
</blockquote>
<blockquote>
<p>计数器必须大于等于0，只是等于0时候，计数器就是零，调用await方法时不会 阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数 器的值。一个线程调用countDown方法happen-before，另外一个线程调用await方法。</p>
</blockquote>
<h2 id="CountDownLatch的使用"><a href="#CountDownLatch的使用" class="headerlink" title="CountDownLatch的使用"></a>CountDownLatch的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">countDownLatchTest</span> <span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(System.currentTimeMillis()+<span class="string">&quot;:&quot;</span>+Thread.currentThread().getName() +<span class="string">&quot;: 执行完成&quot;</span>);</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程全部执行完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1660364051584</span>:pool-<span class="number">1</span>-thread-<span class="number">3</span>: 执行完成</span><br><span class="line"><span class="number">1660364051584</span>:pool-<span class="number">1</span>-thread-<span class="number">2</span>: 执行完成</span><br><span class="line"><span class="number">1660364051584</span>:pool-<span class="number">1</span>-thread-<span class="number">1</span>: 执行完成</span><br><span class="line">线程全部执行完成</span><br></pre></td></tr></table></figure>

<h2 id="CountDownLatch-应用场景"><a href="#CountDownLatch-应用场景" class="headerlink" title="CountDownLatch 应用场景"></a>CountDownLatch 应用场景</h2><p>假如有这样一个需求：我们需要解析一个Excel里多个sheet的数据，此时可以考虑使用多 线程，每个线程解析一个sheet里的数据，等到所有的sheet都解析完之后，程序需要提示解析完 成。在这个需求中，要实现主线程等待所有线程完成sheet的解析操作</p>
<h1 id="CyclicBarrier-和-CountDownLatch-的区别"><a href="#CyclicBarrier-和-CountDownLatch-的区别" class="headerlink" title="CyclicBarrier  和 CountDownLatch 的区别"></a>CyclicBarrier  和 CountDownLatch 的区别</h1><ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数 器，并让线程重新执行一次。</li>
<li>CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得Cyclic-Barrier 阻塞的线程数量。isBroken()方法用来了解阻塞的线程是否被中断。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:18.286Z" title="2025/5/16 11:13:18">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="">java</a></span><span class="level-item">23 分钟读完 (大约3482个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc-%20%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%20%20AbstractQueuedSynchronizer%20%E7%9A%84%E5%AE%9E%E7%8E%B0%20/">AbstractQueuedSynchronizer 的实现</a></p><div class="content"><p>[TOC]</p>
<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>翻译过来是 AbstractQueuedSynchronizer ， 也是我们常说的 AQS 他是很多同步器的基础框架，比如 ReentrantLock、CountDownLatch 和 Semaphore 等都是基于 AQS 实现的。除此之外，我们还可以基于 AQS，定制出我们所需要的同步器。同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的 方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些 模板方法将会调用使用者重写的方法。</p>
<h1 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h1><p><img src="media/17332735927399/17332740833017.jpg"><br>6d7fb03256929308724c2416d09eaca5.png)</p>
<ul>
<li>state 表示同步器的状态 </li>
<li>head 和 tail 组成同步器 的 CLH（虚拟的双向队列）双向队列</li>
<li>ConditionObject 实现了 Condition （也称为条件队列或条件变量）  是每个对象具有了等待集 ， 如果锁取代了同步方法和语句的使用，则条件取代了对象监视器方法的使用。</li>
<li>unsafe  Java中的Unsafe类为我们提供了类似C++手动管理内存的能力。在AQS 执行CAS操作</li>
</ul>
<h2 id="重写同步器"><a href="#重写同步器" class="headerlink" title="重写同步器"></a>重写同步器</h2><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态</p>
<ul>
<li>getState()：获取当前同步状态。 </li>
<li>setState(int newState)：设置当前同步状态。 </li>
<li>compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态 设置的原子性</li>
</ul>
<h2 id="同步器可重写的方法"><a href="#同步器可重写的方法" class="headerlink" title="同步器可重写的方法"></a>同步器可重写的方法</h2><table>
<thead>
<tr>
<th>方法名称</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>独占式获取同步状态，实现该方法需要查询当前状态并频段同步状态是否符合预期，然后再进行CAS设置同步状态</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td>protected int tryAcquireShared</td>
<td>共享式获取同步状态，返回大于等于 0 的值表示获取成功，反之获取失败</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>protected boolean isHeldExclusively()</td>
<td>但钱同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程锁独占</td>
</tr>
<tr>
<td>public final void acquire(int arg)</td>
<td>独占式获取同步状态，如果单线线程同步状态获取成功，则有该方法返回，否则进入同步队列等待</td>
</tr>
<tr>
<td>public final void acquireInterruptibly(int arg)</td>
<td>与acquire(int arg) 相同，但是该方法显影中断，当前线程为获取到同步状态二进入同步队列中，如果当前线程被中断，则该方法会判处InterruptedException并返回</td>
</tr>
<tr>
<td>public final boolean tryAcquireNanos(int arg, long nanosTimeout)</td>
<td>在 acquireInterruptibly 基础上增加了超市限制，如果当前线程在超市时间内没有获取到同步状态，那么会返回false，如果获取到了返回 true</td>
</tr>
<tr>
<td>public final void acquireShared(int arg)</td>
<td>共享式获取同步状态，如果当前线程为获取到同步状态，将会进入同步队列等待，与独占是获取的主要区别式在同一时刻可以又多个线程获取到同步状态</td>
</tr>
<tr>
<td>public final void acquireSharedInterruptibly(int arg)</td>
<td>与  acquireShared(int arg 相同，该方法响应中断</td>
</tr>
<tr>
<td>public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td>
<td>在acquireSharedInterruptibly(int arg)基础上增加了超时限制</td>
</tr>
<tr>
<td>public final boolean release(int arg)</td>
<td>独占式 释放同步状态，该方法在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒</td>
</tr>
<tr>
<td>public final boolean releaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>public final Collection<Thread> getQueuedThreads()</td>
<td>获取等待在同步队列上的线程集合</td>
</tr>
</tbody></table>
<p>同步器提供的方法可以分为三大类</p>
<ul>
<li>独占式获取与释放同步状态、</li>
<li>共享式获取与释放</li>
<li>同步状态和查询同步队列中的等待线程情况</li>
</ul>
<h2 id="同步状态-state"><a href="#同步状态-state" class="headerlink" title="同步状态 state"></a>同步状态 state</h2><p>AQS 中的 state 是 volatile 修饰的 保证了字段可见性  使用 compareAndSetState 对 state进行操作 保证了原子性<br>AQS 获取、释放资源是否成功都是由state决定的</p>
<ul>
<li>ReentrantLock的state用来表示是否有锁资源</li>
<li>ReentrantReadWriteLock的state高16位代表读锁状态，低16位代表写锁状态</li>
<li>Semaphore的state用来表示可用信号的个数</li>
<li>CountDownLatch的state用来表示计数器的值</li>
</ul>
<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><h3 id="node节点"><a href="#node节点" class="headerlink" title="node节点"></a>node节点</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其 加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再 次尝试获取同步状态.<br>同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点，节点的属性类型与名称以及描述</p>
<p><img src="media/17332735927399/17332741107494.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 用于指示节点正在共享模式下等待的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="comment">// 用于指示节点正在独占模式下等待的标记</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示当前节点以取消调度（超时或者被中断） */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示后继节点处于等待状态 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示该节点在等待队列上，调用条件变量的 signal 方法 该节点会从等待队列转移到同步队列 */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/** waitStatus 表示下一次共享式同步状态获取将会无条件被传播下去*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">       <span class="comment">// 前驱节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">  		<span class="comment">// 后继节点</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="comment">// 获取同步状态的线程</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">       	<span class="comment">// 等待队列的后继节点</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="同步队列结构"><a href="#同步队列结构" class="headerlink" title="同步队列结构"></a>同步队列结构</h3><p>当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转 而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式 与之前的尾节点建立关联。<br><img src="media/17332735927399/17332741287115.jpg"></p>
<h3 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h3><p>首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法 保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式 Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）<br>并通过addWaiter(Node node) 方法将该节点加入到同步队列的尾部，<br>最后调用acquireQueued(Node node,int arg)方法，使得该 节点以“死循环”的方式获取同步状态。<br>如果获取不到则阻塞节点中的线程，而被阻塞线程的 唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">		<span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;  </span><br><span class="line">        	<span class="comment">// 构建尾节点 以死循环的方式获取同步状态</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建 Node节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 判断尾节点 是不是空</span></span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        	<span class="comment">// 如果尾节点不等于null，把当前节点的前驱节点指向尾节点</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">// 替换尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果添加失败或队列不存在，执行end函数</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在enq(final Node node)方法中，<strong>同步器通过“死循环”来保证节点的正确添加</strong>，在“死循环”中只有通过CAS将节点设置成为尾节点之后，当前线程才能从该方法返回，否则，当前线 程不断地尝试设置。可以看出，enq(final Node node)方法将并发添加节点的请求通过CAS变 得“串行化”了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//循环</span></span><br><span class="line">            <span class="comment">//获取尾节点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果尾节点为空，创建哨兵节点，通过cas把头节点指向哨兵节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    <span class="comment">//cas成功，尾节点指向哨兵节点</span></span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//当前节点的前驱节点设指向之前尾节点</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//cas设置把尾节点指向当前节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    <span class="comment">//cas成功，之前尾节点的下个节点指向当前节点</span></span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>节点进入同步队列之后，就进入了一个自旋的过程，每个节点（或者说每个线程）都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，<strong>否则依旧留在这 个自旋过程中，并会阻塞节点的线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            	<span class="comment">// 获取前驱节点 </span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点是头节点 ， 获取同步状态</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                	<span class="comment">// 设置当前节点为头节点 也就是哨兵节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否需要挂起当前线程 主要是 判断是否为 Node.SIGNAL 状态， 如果是执行parkAndCheckInterrupt 调用线程的 park 阻塞线程</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                	<span class="comment">// 调用线程的 park 阻塞线程  线程在这里阻塞住 可能被唤醒 或者被打断 返回true 代表线程被打断</span></span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 标记被打断</span></span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        	<span class="comment">//如果出现异常或者出现中断，就会执行finally的取消线程的请求操作，核心代码是node.waitStatus = Node.CANCELLED;将线程的状态改为CANCELLED。</span></span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>队列中各个节点的状态<br><img src="media/17332735927399/17332741550277.jpg"></p>
<p>独占式同步状态获取流程，也就是acquire(int arg)方法调用流程</p>
<p>前驱节点为头节点且能够获取同步状态的判断条件和线程进入等待状态是获取同步状态的自旋过程。当同步状态获取成功之后，当前线程从acquire(int arg)方法返回，如果 对于锁这种并发组件而言，代表着当前线程获取了锁。<br><img src="media/17332735927399/17332741685287.jpg"></p>
<h3 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h3><p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释 放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">		<span class="comment">// 释放同步状态</span></span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">           <span class="comment">// 头节点不为空 且 waitStatus 不等于零</span></span><br><span class="line">           <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">           	<span class="comment">// 调用后继节点的 unpark</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        	<span class="comment">//unpark 唤醒线程</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h2><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。</p>
<p><strong>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的 特性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">doAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line">            <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 到期时间    </span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="comment">// 进入队列尾部</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="comment">// 判断获取同步状态 </span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 计算剩余时间 </span></span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    <span class="comment">// park 当前线程 时间为剩余时间 </span></span><br><span class="line">                    LockSupport.parkNanos(<span class="built_in">this</span>, nanosTimeout);</span><br><span class="line">                <span class="comment">//  判断线程的打断状态 并清空打断状态    </span></span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="media/17332735927399/17332741849881.jpg"></p>
<h2 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h2><p>共享式同步状态获取 与 独占锁的获取基本一直 差别就是共享式支持多个线程共享访问<br>在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是 tryAcquireShared(int arg)方法返回值大于等于0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以<br>释放同步状态</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">// 唤醒后记节点</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="page/0/">上一页</a></div><div class="pagination-next"><a href="page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="">1</a></li><li><a class="pagination-link" href="page/2/">2</a></li><li><a class="pagination-link" href="page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="../../img/avatar.png" alt="zcct"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zcct</p><p class="is-size-6 is-block">zcct</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="../../archives/"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="../../categories/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="../../tags/"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/zclvct" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="../../2024/09/01/redis/GeoHash/">GeoHash</a></p><p class="categories"><a href="../redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="../../2024/09/01/redis/HyperLogLog/">HyperLogLog</a></p><p class="categories"><a href="../redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="../../2024/09/01/redis/PubSub%20%E6%B6%88%E6%81%AF%E5%A4%9A%E6%92%AD%20(%E7%BC%BA%E7%82%B9%E5%A4%9A%E4%B8%8D%E8%A2%AB%E4%BD%BF%E7%94%A8)/">PubSub 消息多播</a></p><p class="categories"><a href="../redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="../../2024/09/01/redis/codis%20%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/">codis 集群方案</a></p><p class="categories"><a href="../redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="../../2024/09/01/redis/redis%20list%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/">redis list应用——延迟队列</a></p><p class="categories"><a href="../redis/">redis</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">63</span></span></a></li><li><a class="level is-mobile" href="../../archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href=""><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="../mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="../redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="../%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="../../tags/juc/"><span class="tag">juc</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/jvm/"><span class="tag">jvm</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/redis/"><span class="tag">redis</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/sql%E4%BC%98%E5%8C%96/"><span class="tag">sql优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"><span class="tag">事务处理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tag">内存模型</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7/"><span class="tag">架构安全性</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="../../tags/%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F/"><span class="tag">透明多级分流系统</span><span class="tag">6</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../index.html"><img src="../../img/logo.svg" alt="ZCCT" height="28"></a><p class="is-size-7"><span>&copy; 2025 zcct</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="../../js/column.js"></script><script src="../../js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="../../js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="../../js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="../../js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="../../js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"../../content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>