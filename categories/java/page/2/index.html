<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>分类: java - ZCCT</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ZCCT"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZCCT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ZCCT"><meta property="og:url" content="https://zcct123.github.io/"><meta property="og:site_name" content="ZCCT"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zcct123.github.io/img/og_image.png"><meta property="article:author" content="zcct"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://zcct123.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://zcct123.github.io"},"headline":"ZCCT","image":["https://zcct123.github.io/img/og_image.png"],"author":{"@type":"Person","name":"zcct"},"publisher":{"@type":"Organization","name":"ZCCT","logo":{"@type":"ImageObject","url":"https://zcct123.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="ZCCT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">档案</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories/">分类</a></li><li class="is-active"><a href="#" aria-current="page">java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:24.756Z" title="2025/5/16 11:13:24">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">26 分钟读完 (大约3904个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized%20%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">synchronized 底层原理</a></p><div class="content"><p>[TOC]</p>
<h1 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=281">来源</a><br>以32位虚拟机为例</p>
<p>普通对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">--------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params"> 							Object Header (64 bits)            </span>|</span><br><span class="line">|<span class="params">------------------------------------</span>|-------------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|      <span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)           |<span class="params">   Klass Word (32 bits)  </span>|</span><br><span class="line">|<span class="params">         （标记字段）                 </span>|         （类型指针）     |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------|<span class="params">-------------------------</span>|</span><br></pre></td></tr></table></figure>
<p>数组对象</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">---------------------------------------------------------------------------------</span>|</span><br><span class="line">|<span class="params"> 						Object Header (96 bits) 								  </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br><span class="line">|<span class="params"> Mark Word(32bits) 			 </span>| <span class="title class_">Klass</span> <span class="title class_">Word</span>(32bits)    |<span class="params"> array length(32bits)   </span>|</span><br><span class="line">|<span class="params">--------------------------------</span>|-----------------------|<span class="params">------------------------</span>|</span><br></pre></td></tr></table></figure>
<p>其中Mark Word结构为</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 						<span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">32</span> bits)			    |<span class="params"> 		State        </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|     <span class="symbol">hashcode:</span><span class="number">25</span>     |<span class="params"> age:4  </span>|  <span class="symbol">biased_lock:</span><span class="number">0</span>  |<span class="params">  01  </span>| 		<span class="title class_">Normal</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:23 </span>| <span class="symbol">epoch:</span><span class="number">2</span> |<span class="params"> age:4  </span>| <span class="symbol">biased_lock:</span><span class="number">1</span>   |<span class="params"> 01   </span>|       <span class="title class_">Biased</span>       |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> 			ptr_to_lock_record:30                </span>| <span class="number">00</span>   |<span class="params"> Lightweight Locked </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 			<span class="symbol">ptr_to_heavyweight_monitor:</span><span class="number">30</span>        |<span class="params"> 10   </span>| <span class="title class_">Heavyweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|-------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> 												 </span>| <span class="number">11</span>   |<span class="params">   Marked <span class="keyword">for</span> GC    </span>|</span><br><span class="line">|<span class="params">-------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br></pre></td></tr></table></figure>
<p>64 位虚拟机 Mark Word</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 						<span class="title class_">Mark</span> <span class="title class_">Word</span> (<span class="number">64</span> bits) 					   |<span class="params"> 		State       </span>|</span><br><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| <span class="symbol">unused:</span><span class="number">25</span> |<span class="params"> hashcode:31 </span>| <span class="symbol">unused:</span><span class="number">1</span> |<span class="params"> age:4 </span>| <span class="symbol">biased_lock:</span><span class="number">0</span> |<span class="params"> 01  </span>| 		<span class="title class_">Normal</span>      |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params"> thread:54 </span>| <span class="symbol">epoch:</span><span class="number">2</span>     |<span class="params"> unused:1 </span>| <span class="symbol">age:</span><span class="number">4</span> |<span class="params"> biased_lock:1 </span>| <span class="number">01</span>  |<span class="params">        Biased      </span>|</span><br><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>| 					<span class="symbol">ptr_to_lock_record:</span><span class="number">62</span>                    |<span class="params"> 00  </span>| <span class="title class_">Lightweight</span> <span class="title class_">Locked</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br><span class="line">|<span class="params">             ptr_to_heavyweight_monitor:62                  </span>| <span class="number">10</span>  |<span class="params"> Heavyweight Locked </span>|</span><br><span class="line">|<span class="params">------------------------------------------------------------------</span>|--------------------|<span class="params"></span></span><br><span class="line"><span class="params"></span>|                                                                  |<span class="params"> 11 </span>| <span class="title class_">Marked</span> <span class="keyword">for</span> <span class="variable constant_">GC</span> |<span class="params"></span></span><br><span class="line"><span class="params"></span>|------------------------------------------------------------------|<span class="params">--------------------</span>|</span><br></pre></td></tr></table></figure>

<h1 id="Monitor（锁）"><a href="#Monitor（锁）" class="headerlink" title="Monitor（锁）"></a>Monitor（锁）</h1><p>Monitor： 被翻译为 <strong>监视器</strong> 或<strong>管程</strong><br><img src="/media/17332747791959/17332748211801.jpg"></p>
<ul>
<li>刚开始Monitor中Owner为null</li>
<li>当Thread-2执行synchronized（obj）就会将Monitor 的所有者Owner置为Thread-2，Monitor中只能有一个Owner</li>
<li>在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized（obj），就会进入EntryList BLOCKED</li>
<li>Thread-2执行完同步代码块的内容，然后唤醒 EntryList中等待的线程来竞争锁，竞争的时是非公平的</li>
<li>图中WaitSet中的Thread-0，Thread-1是之前获得过锁，但条件不满足进入WAITING状态的线程，后面讲wait-notify 时会分析</li>
</ul>
<h3 id="锁的状态"><a href="#锁的状态" class="headerlink" title="锁的状态"></a>锁的状态</h3><p><img src="/media/17332747791959/17332947370901.jpg"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h5 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h5><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），可以用轻量级锁来优化</p>
<ul>
<li>轻量级锁对使用者还是透明的，语法仍然是synchronized</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)</span><br><span class="line">        &#123;<span class="comment">//同步块1</span></span><br><span class="line">         method2();&#125;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//同步块2&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>创建锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录结果，内部可以存储锁定对象的Mark Word（标记字段）<br><img src="/media/17332747791959/17332748418721.jpg"></p>
</li>
<li><p>让锁对象中Object reference 指向，并尝试用cas替换Object的Mark Word，将Mark Word 的值存入锁记录<br><img src="/media/17332747791959/17332748595317.png" alt="在这里插入图片描述"></p>
</li>
<li><p>如果cas替换成功，最想头存储了锁记录地址和状态 00 ，表示有该线程给对象加锁<br><img src="/media/17332747791959/17332748595325.png" alt="在这里插入图片描述"></p>
</li>
<li><p>如果cas失败</p>
<ul>
<li><p>如果是其他线程已经持有该Object的轻量级锁，表明有竞争，进入锁膨胀过程</p>
</li>
<li><p>如果是同一线程执行了 &#x3D;&#x3D;synchronized 锁重入&#x3D;&#x3D; ，那么在天机一条Lock Record作为锁重入的计数<br>  <img src="/media/17332747791959/17332748595335.png" alt="在这里插入图片描述"></p>
</li>
<li><p>当退出synchronized代码块时（解锁时），如果有取值位null的锁记录，表示有锁重入，只是重置锁记录，表示锁重入数减一</p>
</li>
</ul>
</li>
</ul>
<p><img src="/media/17332747791959/17332748595348.png" alt="在这里插入图片描述"></p>
<pre><code>- 当退出synchronized代码块时（解锁时），锁记录部位null ，这时使用cas将 Mark World的值回复给对象头
    - 成功，则结果成功
    - 失败，说明轻量级锁进行了锁膨胀的过程或已经升级为重量级锁，进入重量级锁解锁流程
</code></pre>
<h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><ul>
<li>如果尝试加轻量级锁的过程中，CAS无法成功，这是有其他线程未次对象加上了轻量级锁（有竞争），这是需要进行所鹏展，将轻量级锁变成重量级锁。<ul>
<li><p>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁<br>  <img src="/media/17332747791959/17332748595359.png" alt="在这里插入图片描述"></p>
</li>
<li><p>这是Thread-1加轻量级锁失败，进入做膨胀过程</p>
<ul>
<li>Object对象申请Monitor锁，让Object指向重量级锁的地址</li>
<li>然后自己进入Moniter的RntryList BOLOCED<br>  <img src="/media/17332747791959/17332748596487.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，如果失败，这是会进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，是指Owner为null ，唤醒EntryList中的BLOCKED线程</p>
</li>
</ul>
</li>
</ul>
<h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><p>重量级锁竞争的时候，还可以用自旋来优化，如果当前线程自旋成功（即这时候持锁线程已经推出了同步块，释放了锁）这时当前线程可以避免阻塞进行上下文切换（上下文切换耗费性能）。<br><img src="/media/17332747791959/17332748595371.png" alt="在这里插入图片描述"><br><img src="/media/17332747791959/17332748595384.png" alt="在这里插入图片描述"></p>
<ul>
<li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li>
<li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li>
<li>Java 7 之后不能控制是否开启自旋功能</li>
</ul>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><ul>
<li>轻量级锁在没有竞争时，每次重入依然需要执行CAS操作</li>
<li>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</li>
<li><img src="/media/17332747791959/17332748595400.png" alt="在这里插入图片描述"></li>
</ul>
<h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 						Mark <span class="title function_">Word</span> <span class="params">(<span class="number">64</span> bits)</span> 						| 		State	    |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 	unused:<span class="number">25</span> | hashcode:<span class="number">31</span> | unused:<span class="number">1</span> | age:<span class="number">4</span> | biased_lock:<span class="number">0</span> | <span class="number">01</span> | 		Normal      |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">|   thread:<span class="number">54</span> |  epoch:<span class="number">2</span>    | unused:<span class="number">1</span> | age:<span class="number">4</span> | biased_lock:<span class="number">1</span> | <span class="number">01</span> |       Biased      |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">|   				  ptr_to_lock_record:<span class="number">62</span>					   | <span class="number">00</span> |Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 					ptr_to_heavyweight_monitor:<span class="number">62</span>              | <span class="number">10</span> |Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br><span class="line">| 															   | <span class="number">11</span> |   Marked <span class="keyword">for</span> GC   |</span><br><span class="line">|-------------------------------------------------------------------|-------------------|</span><br></pre></td></tr></table></figure>
<p>一个对象创建时：</p>
<ul>
<li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li>
<li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟</li>
<li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li>
</ul>
<h4 id="锁撤销"><a href="#锁撤销" class="headerlink" title="锁撤销"></a>锁撤销</h4><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点(在这个时间点上没有正在执行的字节码)。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39568133/article/details/114757317">原文</a></p>
<ul>
<li><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销，在调用 hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</p>
<ul>
<li>偏向锁不会记录hashcode</li>
<li>轻量级锁会在锁记录中记录 hashCode</li>
<li>重量级锁会在 Monitor 中记录 hashCode</li>
</ul>
</li>
<li><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>
</li>
<li><p>wait&#x2F;notify 时重量级锁使用的方法 ，调用时偏向锁升级为重量级锁</p>
</li>
</ul>
<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><blockquote>
<p>以class为单位，为每个class维护一个偏向锁撤销计数器。每一次该class的对象发生偏向撤销操作是，该计数器+1，当这个值达到重偏向阈值(默认20)时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。每个class对象也会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时，class中的epoch值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的站，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获取锁时，发现当前对象的epoch值和class不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id改为当前线程ID</p>
</blockquote>
<ul>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID</li>
<li>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</li>
</ul>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><ul>
<li>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><ul>
<li>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享 数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持</li>
</ul>
<h3 id="wait-notify-原理"><a href="#wait-notify-原理" class="headerlink" title="wait notify 原理"></a>wait notify 原理</h3><p><img src="/media/17332747791959/17332748595419.png" alt="在这里插入图片描述"></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</span><br><span class="line">obj.wait()<span class="comment">// 让进入 object 监视器的线程到 waitSet 等待</span></span><br><span class="line">wait(<span class="type">long</span> n) <span class="comment">//有时限的等待, 到 n 毫秒后结束等待，或是被 notify</span></span><br><span class="line">obj.notify() <span class="comment">//在 object 上正在 waitSet 等待的线程中挑一个唤醒</span></span><br><span class="line">obj.notifyAll() <span class="comment">//让 object 上正在 waitSet 等待的线程全部唤醒</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">               log.debug(<span class="string">&quot;执行....&quot;</span>);</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   obj.wait(); <span class="comment">// 让线程在obj上一直等待下去</span></span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               log.debug(<span class="string">&quot;其它代码....&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="comment">// 主线程两秒后执行</span></span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">       log.debug(<span class="string">&quot;唤醒 obj 上其它线程&quot;</span>);</span><br><span class="line">       <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">           obj.notify(); <span class="comment">// 唤醒obj上一个线程</span></span><br><span class="line">           <span class="comment">// obj.notifyAll(); // 唤醒obj上所有等待线程</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">04</span> [Thread-<span class="number">3</span>] c.Test1 - 执行....</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">04</span> [Thread-<span class="number">4</span>] c.Test1 - 执行....</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">06</span> [main] c.Test1 - 唤醒 obj 上其它线程</span><br><span class="line"><span class="number">20</span>:<span class="number">40</span>:<span class="number">06</span> [Thread-<span class="number">3</span>] c.Test1 - 其它代码....</span><br></pre></td></tr></table></figure>

<h3 id="wait-notify-的正确姿势"><a href="#wait-notify-的正确姿势" class="headerlink" title="wait notify 的正确姿势"></a>wait notify 的正确姿势</h3><h4 id="sleep-long-n-和-wait-long-n-的区别"><a href="#sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="sleep(long n) 和 wait(long n) 的区别"></a>sleep(long n) 和 wait(long n) 的区别</h4><ol>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>
<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们状态 TIMED_WAITING</li>
</ol>
<h3 id="保护式暂停模式"><a href="#保护式暂停模式" class="headerlink" title="保护式暂停模式"></a>保护式暂停模式</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者）</li>
<li>JDK 中，join 的实现、Future 的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式<br><img src="/media/17332747791959/17332748595435.png" alt="在这里插入图片描述"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">	 <span class="keyword">private</span> Object response;</span><br><span class="line">	 <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	 <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(Long timeOut)</span> &#123;  <span class="comment">//超时时间</span></span><br><span class="line">		 <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		<span class="comment">// 条件不满足则等待</span></span><br><span class="line">			<span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;   <span class="comment">//防止虚假唤醒</span></span><br><span class="line">				<span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> timeOut - timePassed;  <span class="comment">//计算剩余等待的时间</span></span><br><span class="line">				<span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					lock.wait(waitTime);   <span class="comment">//防止虚假唤醒后 等待时间大于输入时间</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 3) 记录已经经历的时间</span></span><br><span class="line">				timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> response;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">			<span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">			<span class="built_in">this</span>.response = response;</span><br><span class="line">			lock.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">           <span class="comment">// 子线程执行下载</span></span><br><span class="line">           List&lt;String&gt; response = download();</span><br><span class="line">           log.debug(<span class="string">&quot;download complete...&quot;</span>);</span><br><span class="line">           guardedObject.complete(response);</span><br><span class="line">       &#125;).start();</span><br><span class="line">       log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">       <span class="comment">// 主线程阻塞等待</span></span><br><span class="line">       <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObject.get();</span><br><span class="line">       log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">15</span> [main] c.Test1 - waiting...</span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">17</span> [Thread-<span class="number">3</span>] c.Test1 - download complete...</span><br><span class="line"><span class="number">21</span>:<span class="number">13</span>:<span class="number">17</span> [main] c.Test1 - get response: [<span class="number">2</span>] lines</span><br></pre></td></tr></table></figure>
<h3 id="join原理"><a href="#join原理" class="headerlink" title="join原理"></a>join原理</h3><p>利用了&#x3D;&#x3D;保护式暂停模式&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">totalWaited</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> <span class="variable">totalWaited</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 记录共计等待时间</span></span><br><span class="line">	<span class="type">long</span> <span class="variable">toWait</span> <span class="operator">=</span> timeoutInMilliseconds;  <span class="comment">//记录约定等待时间</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">//记录是否超时</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (timeoutInMilliseconds == <span class="number">0</span> &amp; nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// We either round up (1 millisecond) or down (no need to wait, just return)</span></span><br><span class="line">		<span class="keyword">if</span> (nanos &lt; <span class="number">500000</span>)</span><br><span class="line">			timedOut = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			toWait = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (!timedOut &amp;&amp; !isDead()) &#123; <span class="comment">//防止虚假环境，并且判断是否超时</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//记录等待开始时间</span></span><br><span class="line">		wait(toWait);     <span class="comment">// 开始等待 第一次等待时间为约定等待时间  第二次为剩余等待时间</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">waited</span> <span class="operator">=</span> System.currentTimeMillis() - start; <span class="comment">//计算本次循环等待时间</span></span><br><span class="line">		totalWaited+= waited;  <span class="comment">//计算共计等待时间</span></span><br><span class="line">		toWait -= waited;   <span class="comment">//计算等待时间</span></span><br><span class="line">		<span class="comment">// Anyone could do a synchronized/notify on this thread, so if we wait</span></span><br><span class="line">		<span class="comment">// less than the timeout, we must check if the thread really died</span></span><br><span class="line">		timedOut = (totalWaited &gt;= timeoutInMilliseconds);  <span class="comment">//超时判断</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/media/17332747791959/17332748595454.jpg" alt="在这里插入图片描述"></p>
<h3 id="park-Unpark-（搁置、推迟）"><a href="#park-Unpark-（搁置、推迟）" class="headerlink" title="park &amp; Unpark   （搁置、推迟）"></a>park &amp; Unpark   （搁置、推迟）</h3><p>它们是 LockSupport 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">            LockSupport.park();    <span class="comment">//线程进行WAIT状态</span></span><br><span class="line">            log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">        LockSupport.unpark(t1);</span><br></pre></td></tr></table></figure>

<p>与 Object 的 wait &amp; notify 相比</p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li>
<li>&#x3D;&#x3D;park &amp; unpark 可以先 unpark&#x3D;&#x3D;，而 wait &amp; notify 不能先 notify</li>
</ul>
<h4 id="park-unpark-原理"><a href="#park-unpark-原理" class="headerlink" title="park unpark 原理"></a>park unpark 原理</h4><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter（计算器） ， _cond（状态） 和 _mutex （互斥锁）<br><img src="/media/17332747791959/17332748595469.png" alt="在这里插入图片描述"></p>
<ol>
<li>当前线程调用 Unsafe.park() 方法</li>
<li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li>
<li>线程进入 _cond 条件变量阻塞</li>
<li>设置 _counter &#x3D; 0</li>
</ol>
<p><img src="/media/17332747791959/17332748595489.png" alt="在这里插入图片描述"><br>5. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1<br>6. 唤醒 _cond 条件变量中的 Thread_0<br>7. Thread_0 恢复运行<br>8. 设置 _counter 为 0<br><img src="/media/17332747791959/17332748595510.png" alt="在这里插入图片描述"><br> 9. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1<br>10. 当前线程调用 Unsafe.park() 方法<br>11. 检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行<br>12. 设置 _counter 为 0</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:57.218Z" title="2025/5/16 11:12:57">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">10 分钟读完 (大约1516个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B9%8Bvolatile/">共享内存之volatile</a></p><div class="content"><p>[TOC]</p>
<h1 id="并发编程三大性质"><a href="#并发编程三大性质" class="headerlink" title="并发编程三大性质"></a>并发编程三大性质</h1><ul>
<li>原子性：保证指令不会受到线程上下文切换影响</li>
<li>可见性：保证指令不会受cpu缓存影响</li>
<li>有序性：保证指令不会受cpu指令并行优化的影响</li>
</ul>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。</p>
<ul>
<li>volatile关键字 （易变）</li>
</ul>
<p>可以用来修饰成员变量和竞态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须要主存中获取他的值，线程造作volatile变量都是直接操作主存</p>
<ul>
<li>synchronized 加锁也可以保证可见性</li>
</ul>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。</p>
<h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><p>为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。</p>
<ul>
<li>volatile 关键字修饰变量可以避免指令重排序</li>
</ul>
<h1 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h1><p>volatile的底层实现原理是内存屏障，Memory Barrier （Memory Fence）</p>
<ul>
<li>对 volatile 变量的写指令&#x3D;&#x3D;后&#x3D;&#x3D;会加入写屏障</li>
<li>对 volatile 变量的读指令&#x3D;&#x3D;前&#x3D;&#x3D;加入读屏障</li>
</ul>
<h2 id="volatile的两条实现原则"><a href="#volatile的两条实现原则" class="headerlink" title="volatile的两条实现原则"></a>volatile的两条实现原则</h2><ol>
<li>处理器缓存写回主存</li>
<li>一个处理器缓存写回主存时保证其他处理器缓存失效</li>
</ol>
<h2 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h2><ul>
<li>写屏障（sfence）保证了的在该屏障之前的，对共享变量的变动，都同步到主存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span> <span class="params">( I_Result r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = <span class="number">2</span>;</span><br><span class="line">        ready = <span class="literal">true</span> ; <span class="comment">//ready 是 volatile 赋值并带写屏障</span></span><br><span class="line">        <span class="comment">//写屏障    在写屏障之前的num 和 ready 都同步到主存中</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的主存中最新的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span> <span class="params">( I_Result r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//读屏障</span></span><br><span class="line">        <span class="keyword">if</span>(ready)   <span class="comment">//ready 是 volatile 读取值并带读屏障</span></span><br><span class="line">        &#123;</span><br><span class="line">            r.r1= num + num;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r.r1 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，写屏障保证了 写之前所有共享变量的可见性，读屏障保证了读之后所有变量的可见性<br><img src="/media/17332739938932/17332742200767.jpg"></p>
<h2 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h2><ul>
<li><p>写屏障会确保指令重排时，不会将写屏障之前的代码排在写屏障之后<br><img src="/media/17332739938932/17332742329368.jpg"></p>
</li>
<li><p>读屏障会确保指令重排时，不会将读屏障之后的代码排在读屏障之前<br><img src="/media/17332739938932/17332742452020.jpg"></p>
</li>
</ul>
<p><img src="/media/17332739938932/17332742613456.jpg"></p>
<h1 id="DCL-问题-double-checked-locking-问题"><a href="#DCL-问题-double-checked-locking-问题" class="headerlink" title="DCL  问题 double-checked locking 问题"></a>DCL  问题 double-checked locking 问题</h1><p>double-checked locking单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANSE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANSE == <span class="literal">null</span>) &#123;   <span class="comment">//无法保证 有序性 原子性 和 可见性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANSE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANSE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   <span class="comment">//这里 构造函数初始化 和 实例赋值 可能出现重排序</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>懒惰实例化</li>
<li>首次使用getInstance时加锁 ，后续使用无需加锁</li>
<li>有隐含的。但很关键的一点：第一个if使用了INSTANSE 变量，是在同步块之外<br><img src="/media/17332739938932/17332743110810.jpg"></li>
</ul>
<p>INSTANSE &#x3D; new Singleton(); 实际上不是原子操作  发生指令重排之后，第一步赋值 ，第二步调用构造方法，当他复制结束还没有调用构造方法时 ，另一个线程操作 if (INSTANSE &#x3D;&#x3D; null)  ，而此时这个操作在同步代码块之外，所以这是返回一个空的实例对象</p>
<p>&#x3D;&#x3D;这里可以利用 volatile 利用读写屏障保证指令重排&#x3D;&#x3D;</p>
<h2 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h2><p>happens-before 规定了对共享变量的写操作对其他线程的读操作可见，他是可见性与有序性的一套规则总结</p>
<ul>
<li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其他线程对改变量的读可见<br><img src="/media/17332739938932/17332743241994.jpg"></p>
</li>
<li><p>线程对volatile 变量的写，对接下来其他线程对改变量的读可见<br><img src="/media/17332739938932/17332743364507.jpg"></p>
</li>
<li><p>线程start之前对变量的写，对该线程开始后对该变量的读可见</p>
</li>
<li><p>线程结束前对该变量的写，对其他线程得知他结束后的读可见</p>
</li>
<li><p>线程t1打断线程t2前对变量的写，对于其他线程得知t2被打断后对变脸的读可见</p>
</li>
<li><p>对变量默认值的写，对其他线程对该变量的读可见</p>
</li>
<li><p>具有传递性<br><img src="/media/17332739938932/17332743511507.jpg"></p>
</li>
</ul>
<h1 id="线程安全问题-单例模式"><a href="#线程安全问题-单例模式" class="headerlink" title="线程安全问题-单例模式"></a>线程安全问题-单例模式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;   <span class="comment">//这里存在反序列化问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;  <span class="comment">//不能防止反射创建实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANSE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//类初始化时初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">readResovle</span><span class="params">()</span>&#123;  <span class="comment">//反序列化问题解决方式  JVM从内存中反序列化地&quot;组装&quot;一个新对象时,就会自动调用这个 </span></span><br><span class="line">    								<span class="comment">//readResolve方法来返回我们指定好的对象了, 单例规则也就得到了保证.</span></span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANSCE   <span class="comment">//不能用反射破环单例   可以避免反序列化破坏单例  属于饿汉式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;  <span class="comment">//每次加锁 浪费资源</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DCL</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//防止指令重排序 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE== <span class="literal">null</span>) &#123;   </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;   <span class="comment">//防止 创建实例不是原子性引发的问题</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">//静态内部类 静态的线程安全 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.INSTANCE;  <span class="comment">//懒汉式  类加载时懒惰的 ，第一次使用时触发加载</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:13:04.390Z" title="2025/5/16 11:13:04">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">12 分钟读完 (大约1847个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/juc%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/">线程池中线程执行任务发生异常会怎么样</a></p><div class="content"><ol>
<li>线程池提交任务有两个方法<ul>
<li>submit</li>
<li>execute</li>
</ul>
</li>
</ol>
<h2 id="使用-execute-提交任务"><a href="#使用-execute-提交任务" class="headerlink" title="使用 execute 提交任务"></a>使用 execute 提交任务</h2><ol>
<li><p>测试代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">     <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">         <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">             <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">             thread.setName(<span class="string">&quot;threadFactory-&quot;</span>+index);</span><br><span class="line">             index.incrementAndGet();</span><br><span class="line">             <span class="keyword">return</span> thread;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(), threadFactory);</span><br><span class="line">	</span><br><span class="line">     threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName());</span><br><span class="line">          <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">     TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">     threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName());</span><br><span class="line">     &#125;);</span><br><span class="line">	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行结果</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">threadFactory-<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;threadFactory-1&quot;</span> java.lang.ArithmeticException: 除以零</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest.lambda$main$<span class="number">0</span>(ThreadPollTest.java:<span class="number">28</span>)</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest$$Lambda$<span class="number">1</span>/00000000037A8980.run(Unknown Source)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">823</span>)</span><br><span class="line">threadFactory-<span class="number">2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分析结果<br> 在执行中结果中也可看出，execute执行方式抛出异常显示在控制台了 ，并且再次提交任务，发现是另一个线程去执行的任务</p>
</li>
<li><p>源码分析<br> 在线程中提交任务是把任务包装成 worker 对象， 调用 runWorker 来执行，一下是 runWorker 方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">        w.firstTask = <span class="literal">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>我们只看这里的主要部分<br>    1. beforeExecute(wt, task); 执行调用前的钩子方法<br>    2.  task.run(); 执行任务<br>    3.  afterExecute(task, thrown); 执行调用后的钩子方法<br>    4. processWorkerExit(w, completedAbruptly);<br>其中  afterExecute(task, thrown); 在 finally 代码块中 ，并且 传递了任务本身和异常信息，可以在发生异常时提供业务补偿的方式<br>同时 <strong>从代码中可以看出 虽然 catch 到异常了 但是没有处理 而是直接抛出</strong>。<br>在最外层调用了<strong>processWorkerExit(w, completedAbruptly);</strong><br>来看一下这个方法中做了什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">	        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span></span><br><span class="line">	            decrementWorkerCount();</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">	        mainLock.lock();</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	            completedTaskCount += w.completedTasks;</span><br><span class="line">	            workers.remove(w);</span><br><span class="line">	        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	            mainLock.unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        tryTerminate();</span><br><span class="line">	</span><br><span class="line">	        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">	        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">	                <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">	                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">	                    min = <span class="number">1</span>;</span><br><span class="line">	                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">	                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">	            &#125;</span><br><span class="line">	            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure>
<p>processWorkerExit 方法有两个参数，第一个参数是执行的 worker 对象， 第二个参数 代表 执行过程中是否发生了异常<br>执行步骤</p>
<ol>
<li>判断是否是意外退出的，如果是意外退出的话，那么就需要把WorkerCount–</li>
<li>加完锁后，将completedTaskCount，表示总共完成的任务数，并且从WorkerSet中将对应的Worker移除 </li>
<li>判断当前的线程池状态，是否终止线程池</li>
<li>判断线程池的状态是否小于STOP，也就是处于RUNNING或者SHUTDOWN状态，如果不是不执行</li>
<li>上一步判断返回true 则判断线程是否抛出异常<br>  1）如果allowCoreThreadTimeOut&#x3D;true且队列不为空，那么需要至少保证有一个线程<br>  2）如果allowCoreThreadTimeOut&#x3D;false,那么需要保证线程数大于等于corePoolSize</li>
<li>如果线程抛出异常 放一个空的 worker 尝试新建一个线程</li>
</ol>
<h2 id="使用-execute-提交任务总结"><a href="#使用-execute-提交任务总结" class="headerlink" title="使用 execute 提交任务总结"></a>使用 execute 提交任务总结</h2><p>execute 提交任务时，当执行发生异常，那么会直接抛出异常，并且移除异常线程也就是 worker ，并且尝试放入一个新的线程</p>
<h2 id="使用-submit-提交任务"><a href="#使用-submit-提交任务" class="headerlink" title="使用 submit 提交任务"></a>使用 submit 提交任务</h2><ol>
<li><p>测试代码</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">       <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">           <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">               <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">               thread.setName(<span class="string">&quot;threadFactory-&quot;</span>+index);</span><br><span class="line">               index.incrementAndGet();</span><br><span class="line">               <span class="keyword">return</span> thread;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(), threadFactory);</span><br><span class="line">	</span><br><span class="line">       Future&lt;Object&gt; future = (Future&lt;Object&gt;) threadPoolExecutor.submit(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">           <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">       &#125;);</span><br><span class="line">	</span><br><span class="line">       TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">       threadPoolExecutor.execute(() -&gt; &#123;</span><br><span class="line">           System.out.println(Thread.currentThread().getName());</span><br><span class="line">       &#125;);</span><br><span class="line">       future.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行结果</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadFactory-<span class="number">1</span></span><br><span class="line">threadFactory-<span class="number">1</span></span><br><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.util.concurrent.ExecutionException: java.lang.ArithmeticException: 除以零</span><br><span class="line">	at java.util.concurrent.FutureTask.report(FutureTask.java:<span class="number">122</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.get(FutureTask.java:<span class="number">192</span>)</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest.main(ThreadPollTest.java:<span class="number">35</span>)</span><br><span class="line">Caused by: java.lang.ArithmeticException: 除以零</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest.lambda$main$<span class="number">0</span>(ThreadPollTest.java:<span class="number">28</span>)</span><br><span class="line">	at com.zclvct.leetcode.ThreadPollTest$$Lambda$<span class="number">1</span>/000000000432EA90.run(Unknown Source)</span><br><span class="line">	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.run$$$capture(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">	at java.util.concurrent.FutureTask.run(FutureTask.java)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">823</span>)</span><br></pre></td></tr></table></figure>
<p> 从运行结果上来看 使用submit提交的任务，发生异常 ，不会立刻抛出异常，而是当 调用future.get();时发生异常，同时执行异常的线程没有被抛弃</p>
</li>
<li><p>源码分析<br> submit 提交的任务 实际上是调用FutureTask类的run方法如下： 这里他能提交 Runable 还有 Callable也是使用了适配器模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="type">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="literal">null</span>;</span><br><span class="line">                    ran = <span class="literal">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 从以上代码执行中我们可以看出  result &#x3D; c.call(); 被包裹在 try 代码块中，并且这里并没有和 runWorker 一样 经过异常抛出，而是在发生异常是调用了  setException(ex);  方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setException</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">            outcome = t;</span><br><span class="line">            UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">            finishCompletion();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 	setException 中 把异常信息保存了下来 ，并通过cas 操作 FutureTask 的状态为异常状态<br>当调用get方法时，查看是异常状态则抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">     <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">     <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">         <span class="keyword">return</span> (V)x;</span><br><span class="line">     <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-submit-提交任务-总结"><a href="#使用-submit-提交任务-总结" class="headerlink" title="使用 submit 提交任务 总结"></a>使用 submit 提交任务 总结</h2><p>使用 submit 提交任务 发生异常不会直接抛出，也不会移除当前执行异常的线程，而是将异常保存在 FutureTask中，当调用get时抛出异常。</p>
<h1 id="setUncaughtExceptionHandler-方法详解"><a href="#setUncaughtExceptionHandler-方法详解" class="headerlink" title="setUncaughtExceptionHandler 方法详解"></a>setUncaughtExceptionHandler 方法详解</h1><p>先对对象维护了 一个 	private volatile UncaughtExceptionHandler exceptionHandler; 异常处理器</p>
<p>thread 定义了 一个 uncaughtException方法 ，当线程执行出现异常的时候，相当于会回调 UncaughtExceptionHandler 接口，通过 getUncaughtExceptionHandler 方法查看当前线程是否设置了 UncaughtExceptionHandler。有就调用，由于线程在创建的时候都会属于一个 ThreadGroup，会尝试调用 ThreadGroup 的 UncaughtExceptionHandler，如果还是没有设置，那么会调用 getDefaultUncaughtExceptionHandler 获取全局默认的 UncaughtExceptionHandler。</p>
<blockquote>
<p>Interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception.<br>When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler’s uncaughtException method, passing the thread and the exception as arguments. If a thread has not had its UncaughtExceptionHandler explicitly set, then its ThreadGroup object acts as its UncaughtExceptionHandler. If the ThreadGroup object has no special requirements for dealing with the exception, it can forward the invocation to the default uncaught exception handler.</p>
</blockquote>
<p>当线程由于未捕获的异常而突然终止时调用的处理程序接口。<br>当线程由于未捕获的异常而即将终止时，Java 虚拟机将使用 Thread.getUncaughtExceptionHandler() 查询线程的 UncaughtExceptionHandler 并将调用处理程序的 uncaughtException 方法，将线程和异常作为参数传递。 如果一个线程没有显式设置它的 UncaughtExceptionHandler，那么它的 ThreadGroup 对象充当它的 UncaughtExceptionHandler。 如果 ThreadGroup 对象对处理异常没有特殊要求，则可以将调用转发给默认的未捕获异常处理程序</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:28.564Z" title="2025/5/16 11:12:28">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">26 分钟读完 (大约3959个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/7%E7%A7%8D%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">7种经典垃圾收集器</a></p><div class="content"><p>[TOC]</p>
<h2 id="HotSpot虚拟机的垃圾收集器"><a href="#HotSpot虚拟机的垃圾收集器" class="headerlink" title="HotSpot虚拟机的垃圾收集器"></a>HotSpot虚拟机的垃圾收集器</h2><p>两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p>
<p><img src="/media/17308811963792/17312887172963.jpg"></p>
<h2 id="新生代收集器"><a href="#新生代收集器" class="headerlink" title="新生代收集器"></a>新生代收集器</h2><h3 id="Serial（串行）收集器"><a href="#Serial（串行）收集器" class="headerlink" title="Serial（串行）收集器"></a>Serial（串行）收集器</h3><p>Serial收集器是一个<strong>单线程工作</strong>的收集器，但它的“单线 程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>
<p><img src="/media/17308811963792/17312889798159.jpg"></p>
<ul>
<li>优点<ul>
<li>简单高效：由于是单线程的，实现简单，开销较小。</li>
<li>资源消耗低：不会占用过多的系统资源，适用于小型应用或客户端环境。</li>
<li>易于调试：由于是单线程的，调试和问题定位相对容易。</li>
</ul>
</li>
<li>缺点<ul>
<li>性能瓶颈：在多核处理器上，单线程的垃圾回收可能会成为性能瓶颈。</li>
<li>较长的停顿时间：由于是单线程的，垃圾回收的停顿时间可能会比较长，不适合对响应时间有严格要求的应用。</li>
</ul>
</li>
<li>使用场景<ul>
<li>小型应用：适用于小型应用或客户端环境，如桌面应用、嵌入式设备等。</li>
<li>开发和测试：在开发和测试环境中，Serial收集器因其简单性和低资源消耗而常被使用</li>
</ul>
</li>
</ul>
<h3 id="ParNew-（Parallel-New）（并行）收集器"><a href="#ParNew-（Parallel-New）（并行）收集器" class="headerlink" title="ParNew （Parallel New）（并行）收集器"></a>ParNew （Parallel New）（并行）收集器</h3><p>ParNew收集器实质上是<strong>Serial收集器的多线程并行版本</strong>，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、-XX： PretenureSizeThreshold、-XX：HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。</p>
<p><img src="/media/17308811963792/17312923318115.jpg"></p>
<ul>
<li><p>优点</p>
<ul>
<li>并行性：通过多线程并行工作，减少了垃圾回收的停顿时间。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>停顿时间：虽然吞吐量高，但停顿时间可能会比其他收集器长，不适合对响应时间有严格要求的应用。</li>
<li>内存开销：并行回收会占用更多的系统资源</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>多核处理器：在多核处理器上，ParNew收集器可以充分利用多线程的优势，提高垃圾回收的效率。</li>
<li>中等规模应用：对于中等规模的应用，ParNew收集器是一个不错的选择，因为它可以在保证性能的同时，减少停顿时间。</li>
<li>与CMS配合使用：ParNew收集器通常与CMS（Concurrent Mark-Sweep）收集器配合使用，用于年轻代的垃圾回收，而CMS用于老年代的垃圾回收。</li>
</ul>
</li>
</ul>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。</p>
<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吞吐量 = \frac&#123;运行用户代码时间&#125;&#123;运行用户代码时间+运行垃圾收集时间)&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>Parallel Scavenge收集器也经常被称作“吞吐量优先收集器”，<strong>可以根据应用程序的运行情况自动调整垃圾回收的参数，以达到最佳性能。</strong> +UseAdaptiveSizePolicy当这个参数被激活之后，就不需要人工指定新生代的大小、Eden与Survivor区的比例、晋升老年代对象大小等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时 间或者最大的吞吐量。这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）。</p>
<ul>
<li><p>优点</p>
<ul>
<li>高吞吐量：Parallel Scavenge收集器的设计目标是最大化吞吐量，即尽可能多地让应用程序运行，减少垃圾回收的时间。</li>
<li>并行性：通过多线程并行工作，减少了垃圾回收的停顿时间。<br>自适应调整：可以根据应用程序的运行情况自动调整垃圾回收的参数，以达到最佳性能。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>停顿时间：虽然吞吐量高，但停顿时间可能会比其他收集器长，不适合对响应时间有严格要求的应用。</li>
<li>内存开销：并行回收会占用更多的系统资源。</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>批处理任务：对于批处理任务或后台处理任务，Parallel Scavenge收集器是一个不错的选择，因为它可以最大化吞吐量。</li>
<li>大数据处理：在大数据处理场景中，Parallel Scavenge收集器可以有效地利用多核处理器的优势，提高处理速度</li>
</ul>
</li>
</ul>
<h2 id="老年代收集器"><a href="#老年代收集器" class="headerlink" title="老年代收集器"></a>老年代收集器</h2><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old收集器是一个单线程收集器，使用标记-整理算法。这个收集器的<strong>主要意义也是供客户端模式下的HotSpot虚拟机使用</strong>。如果在服务端模式下，它也可能有两种用途：一种是在JDK5以及之前的版本中与Parallel Scavenge收集器搭配使用，另外一种就是作为CMS收集器发生失败时的后备预案。</p>
<p><img src="/media/17308811963792/17314826936057.jpg"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。<br>在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>
<p><img src="/media/17308811963792/17314833096585.jpg"></p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS（Concurrent Mark Sweep ）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p>CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤。</p>
<pre><code>1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep ）
</code></pre>
<ol>
<li><p>初始标记</p>
<p> 标记一下GC Roots能直接关联到的对象，需要Stop the world</p>
</li>
<li><p>并发标记</p>
<p> 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</p>
</li>
<li><p>重新标记</p>
<p> 重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。</p>
<p> 这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</p>
</li>
<li><p>并发清除</p>
<p> 清理删除掉标记阶段判断的已经死亡的对象，由于CMS收集器是基于标记-清除算法不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发。</p>
<p> <img src="/media/17308811963792/17314859850102.jpg"></p>
</li>
</ol>
<h4 id="CMS收集器缺点"><a href="#CMS收集器缺点" class="headerlink" title="CMS收集器缺点"></a>CMS收集器缺点</h4><ol>
<li><p><strong>CMS收集器对处理器资源非常敏感</strong>，虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的 算能力），降低总吞吐量。CMS默认启动的回收线程数是（处理器核心数量 +3）&#x2F;4</p>
</li>
<li><p><strong>CMS收集器无法处理“浮动垃圾”</strong>（Floating Garbage），有可能出现“Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<p> -XX：CMSInitiatingOccu-pancy Fraction cms触发内存百分比</p>
<p> 同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（ConcurrentM ode Failure），这时候虚拟机将 得不启动后备预案：冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。</p>
</li>
<li><p>CMS是一款基于“标记-清除”算法实现的收集器，<strong>空间碎片过多会导致大对象分配困难</strong>，即使老年代还有很多剩余空间，也可能因为找不到足够大的连续空间而不得不提前触发一次Full GC。</p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection：<br> 在CMS收集器不得不进行Full GC时，开启内存碎片的合并整理过程。默认是开启的。内存整理必须移动存活对象，无法并发进行，导致停顿时间变长。从JDK 9开始废弃。</li>
<li>-XX:CMSFullGCsBeforeCompaction：<br> 要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理。默认值为0，表示每次进入Full GC时都进行碎片整理。通过控制碎片整理的频率，平衡停顿时间和空间碎片问题。从JDK 9开始废弃</li>
</ul>
</li>
</ol>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><p>G1是一款主要面向服务端应用的垃圾收集器。G1收集器旨在减少垃圾收集过程中的停顿时间，同时保持较高的吞吐量。可以由用户指定期望的停顿时间，与CMS 的“标记-清除”算法不同，<strong>G1从整体来看是基于“标记-整理”算法实现的收集器，但从局部（两个Region 之间）上看又是基于“标记-复制”算法实现</strong>，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。</p>
<p>G1<strong>基于Region的堆内存布局</strong>，G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p>
<p>它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。 这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获 取尽可能高的收集效率。</p>
<p><img src="/media/17308811963792/17320830538439.jpg"></p>
<p>运作过程大致可划分为以下四个步骤：</p>
<ul>
<li><p>初始标记（Initial M arking）：</p>
<p>  仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要 停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</p>
</li>
<li><p>并发标记（Concurrent Marking）：</p>
<p>  从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>
</li>
<li><p>最终标记（Final Marking）：</p>
<p>  对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</p>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation）：</p>
<p>  负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p>
<p>  <img src="/media/17308811963792/17320838622797.jpg"></p>
</li>
</ul>
<blockquote>
<p>回收阶段（Evacuation）其实本也有想过设计成与用户程序 一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回收一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC） 中</p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:50.729Z" title="2025/5/16 11:12:50">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">17 分钟读完 (大约2518个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/GC%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">GC中基本概念</a></p><div class="content"><p>[TOC]</p>
<h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><br/>
    
<p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但<strong>根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者几乎不会发生停顿的CMS、G1、ZGC等收集器，枚举根节点时也是必须要停顿的。</p>
<p>当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap（Ordinary Object Pointer Map）</strong> 的数据结构来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>
<h3 id="OopMap（Ordinary-Object-Pointer-Map）普通对象指针图"><a href="#OopMap（Ordinary-Object-Pointer-Map）普通对象指针图" class="headerlink" title="OopMap（Ordinary Object Pointer Map）普通对象指针图"></a>OopMap（Ordinary Object Pointer Map）普通对象指针图</h3><p>OopMap是 HotSpot 虚拟机中的一个重要概念，主要用于垃圾回收和异常处理。以下是关于 OopMap 的关键点：</p>
<ul>
<li>定义：<br>OopMap 是一个位图，记录了方法执行过程中各个寄存器和栈位置中哪些位置存储了对象引用（OOPs, Ordinary Object Pointers）。</li>
<li>用途：<ul>
<li>垃圾回收：在垃圾回收过程中，OopMap 帮助快速定位到所有活动的对象引用，从而确定哪些对象是可达的，哪些可以被回收。</li>
<li>异常处理：在发生异常时，OopMap 帮助虚拟机快速恢复到异常处理代码的位置，并确保所有对象引用的正确性。</li>
</ul>
</li>
<li>生成时机：<br>OopMap 在方法编译时生成，由 JIT 编译器负责创建。<br>编译器会在方法的关键点（如 safepoint 检查点）生成 OopMap，以便在这些点上进行垃圾回收或异常处理。</li>
</ul>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><br/>

<ul>
<li>定义：<br>  安全点是JVM可以安全地中断线程而不影响程序正确性的点。</li>
<li>用途：<ul>
<li>垃圾回收：在进行垃圾回收时，JVM需要确保所有线程都处于一个稳定状态，以便安全地回收不再使用的对象。</li>
<li>线程调度：在进行线程调度时，JVM可以利用安全点来暂停或恢复线程。</li>
<li>动态代码优化：JIT编译器可以在安全点对字节码进行优化。</li>
</ul>
</li>
<li>触发条件：<ul>
<li>显式调用：通过System.gc()等方法显式请求垃圾回收。</li>
<li>内存不足：当堆内存不足时，JVM会自动触发垃圾回收。</li>
<li>定时检查：JVM会定期检查是否需要进行垃圾回收或其他维护操作。</li>
</ul>
</li>
<li>实现机制：<ul>
<li>轮询：JVM在每个安全点位置插入轮询代码，检查是否需要暂停线程。</li>
<li>同步屏障：在多线程环境中，JVM使用同步屏障确保所有线程都能到达安全点。</li>
</ul>
</li>
<li>性能影响：<ul>
<li>暂停时间：频繁的垃圾回收会导致“停顿”（Stop-The-World），影响应用程序的响应时间。</li>
<li>优化：现代JVM通过各种优化技术（如增量收集、并发收集等）减少安全点的性能开销。</li>
</ul>
</li>
</ul>
<br/>    


<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><br/>

<p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集 过程的安全点。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配处理器时间，典型的 场景便是<strong>用户线程处于Sleep 状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己</strong>，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（Safe Region）来解决。    </p>
<ul>
<li><p>定义：</p>
<p>  安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
</li>
</ul>
<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举（或者垃圾收集过程中其他需要暂停用户线程的阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>
<br/>    


<h2 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h2><br/>   

<ul>
<li>定义</li>
</ul>
<p>记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合</strong>的抽象数据结构。</p>
<ul>
<li><p>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。 </p>
<p>  “卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集[1]，这也是目前最常用的一种记忆集实现形式。</p>
<p>  记忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。</p>
</li>
</ul>
<p>字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个 内存块被称作“卡页”（Card Page）。一般来说，卡页大小都是以2的N次幂的字节数，通过上面代码可 以看出HotSp ot中使用的卡页是2的9次幂，即512字节（地址右移9位，相当于用地址除以512）。那如果卡表标识内存区域的起始地址是0x0000的话，数组CARD_TABLE的第0、1、2号元素，分别对应了 地址范围为0x0000～0x01FF、0x0200～0x03FF、0x0400～0x05FF的卡页内存块[4]</p>
<p><img src="/media/17307908497054/17307963120093.jpg"></p>
<p>一个卡页的内存中通常包含不止一个对象，<strong>只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏（Dirty ），没有则标识为0</strong>。<strong>在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。</strong></p>
<br/>    


<h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><br/> 

<p>写屏障可以看作在虚拟机层面对*<em>引用类型字段赋值</em>这个动作的AOP切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的 前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier)。</p>
<ul>
<li>定义<br>写屏障是一种在对象引用发生变化时插入的额外代码，用于通知垃圾回收器对象引用的更改。通过写屏障，垃圾回收器可以及时更新其内部的数据结构，确保在垃圾回收过程中能够准确地识别出所有可达对象。</li>
<li>作用<ul>
<li>增量更新：在对象引用发生变化时，立即更新相关数据结构，避免在垃圾回收时进行全量扫描。</li>
<li>并发标记：支持并发垃圾回收，允许多个线程同时运行应用程序和垃圾回收器，提高整体性能。</li>
</ul>
</li>
<li>实现方式<ul>
<li>预写屏障（Pre-Write Barrier）：在写操作之前插入的屏障，通常用于记录对象引用的变化。</li>
<li>后写屏障（Post-Write Barrier）：在写操作之后插入的屏障，用于更新相关数据结构。</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:46.862Z" title="2025/5/16 11:12:46">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">8 分钟读完 (大约1274个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0/">三色标记</a></p><div class="content"><p>[TOC]</p>
<br/>

<p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行。在根节点枚举这个步骤中，由于GC Roots相比 起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧（如OopMap ）的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。可<strong>从GC Roots再继续往下遍历对象图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系</strong>：<strong>堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。</strong></p>
<br/>

<h2 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h2><p>三色标记（Tri-color Marking）把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：<br><br/></p>
<ul>
<li><p>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p>
</li>
<li><p>黑色：表示对象已经被垃圾收集器访问过，且<strong>这个对象的所有引用都已经扫描过</strong>。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</p>
</li>
<li><p>灰色：表示对象已经被垃圾收集器访问过，但<strong>这个对象上至少存在一个引用还没有被扫描过</strong>。</p>
</li>
</ul>
<p>如果在标记过程中用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是并发工作，收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果：</p>
<ol>
<li><strong>多标</strong>：把原本消亡的对象错误标记为存活，这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</li>
<li><strong>漏标</strong>：把原本存活的对象错误标记为已消亡，这就是非常致命的后果，程序肯定会因此发生错误。</li>
</ol>
<p><img src="/media/17308567619994/17316559737619.jpg"></p>
<p>Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是<strong>黑色的对象被误标为白色</strong>：</p>
<ul>
<li><p>赋值器插入了一条或多条从黑色对象到白色对象的新引用</p>
</li>
<li><p>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</p>
</li>
</ul>
<p>我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别 产生了两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。</p>
<ol>
<li>增量更新</li>
</ol>
<p>增量更新要破坏的是第一个条件，<strong>当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来</strong>，<strong>等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次</strong>。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>
<ol>
<li>原始快照</li>
</ol>
<p>原始快照要破坏的是第二个条件，<strong>当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来</strong>，<strong>在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次</strong>。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</p>
<p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，<u>CMS是基于增量更新来做并发标记的，G1、Shenandoah则是用原始快照来实现</u></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:35.632Z" title="2025/5/16 11:12:35">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">6 分钟读完 (大约837个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA/">分代收集理论</a></p><div class="content"><p>[TOC]</p>
<br/>

<h2 id="分代假说"><a href="#分代假说" class="headerlink" title="分代假说"></a>分代假说</h2><p>它建立在三个分代假说之上：</p>
<ol>
<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<br/>

<p>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储：</p>
<p>如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只<strong>关注如何保留少量存活而不是去标记那些大量将要被回收的对象</strong>，就能以较低代价回收到大量的空间；*—- 弱分代假说*</p>
<p>如果剩下的都是难以消亡的对象，那把它们集中放在一块， 虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。*—- 强分代假说*</p>
<p>我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，<strong>只需在新生代上建立一个全局的数据结构（该结构被称 为“记忆集”，Remembered Set</strong>），<strong>这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用</strong>。此后当发生MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的.   <em>—- 跨代引用假说</em></p>
<h2 id="GC收集名称定义"><a href="#GC收集名称定义" class="headerlink" title="GC收集名称定义"></a>GC收集名称定义</h2><p>部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：<br><br/></p>
<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：指目标只是新生代的垃圾收集。</li>
<li>老年代收集（Major GC&#x2F;Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</li>
</ul>
<br/>

<p>整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:31.831Z" title="2025/5/16 11:12:31">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">26 分钟读完 (大约3902个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">低延迟垃圾收集器</a></p><div class="content"><p>[TOC]</p>
<p>下图中浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。</p>
<p>在CMS和G1之前的全部收集器，其工作的所有步骤都会产生“Stop The World”式的停顿； CMS和G1分别使用增量更新和原始快照技术，实现了标记阶段的并发，不会因管理的堆内存变大，要标记的对象变多而导致停顿时间随之增长。但是对于标记阶段之后的处理，仍未得到妥善解决。<br><strong>CMS使用标记-清除算法，虽然避免了整理阶段收集器带来的停顿，但是清除算法不论如何 化改进，在设计原理上避免不了空间碎片的产生，随着空间碎片不断淤积最终依然逃不过“Stop The World”的命运</strong>。<br><strong>G1虽然可以按更小的粒度进行回收，从而抑制整理阶段出现时间过长的停顿，但毕竟 也还是要暂停的</strong>。</p>
<p><img src="/media/17321588916542/17321596868873.jpg"></p>
<h1 id="Shenandoah-谢南多亚-收集器"><a href="#Shenandoah-谢南多亚-收集器" class="headerlink" title="Shenandoah(谢南多亚)收集器"></a>Shenandoah(谢南多亚)收集器</h1><p>Shenandoah也是使用基于Region的堆内存布局，同样 有着用于存放大对象的Humongous Region，默认的回收策略也同样是优先处理回收价值最大的 Region……但在管理堆内存方面，它与G1至少有三个明显的不同之处.</p>
<ol>
<li>支持并发的整理算法,G1的回收阶段是可以多线程并行的，但却不能与用户线程并发.</li>
<li>Shenandoah（目前）是默认不使用分代收集的，换言之，不会有 专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值， 这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上.</li>
<li>Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率.</li>
</ol>
<p><img src="/media/17321588916542/17321668602765.jpg"></p>
<ul>
<li><p>初始标记（Initial Marking）：</p>
<p>  与G1一样，首先标记与GC Roots直接关联的对象，这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关。</p>
</li>
<li><p>并发标记（Concurrent Marking）：</p>
<p>  与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</p>
</li>
<li><p>最终标记（Final M arking）：</p>
<p>  与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值 最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。</p>
</li>
<li><p>并发清理（Concurrent Cleanup ）：</p>
<p>  这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region（这类Region被称为Immediate Garbage Region)。</p>
</li>
<li><p>并发回收（Concurrent Evacuation）：</p>
<p>  并发回收阶段是Shenandoah与之前HotSpot中其他收集器的核心差异。在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象 进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小。</p>
</li>
<li><p>初始引用更新（Initial Update Reference）：</p>
<p>  并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。引用更新的初始化阶段实际上并未做什么具体的处理，设立这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务而已。初始引用更新时间很短，会产生一个非常短暂的停顿。</p>
</li>
<li><p>并发引用更新（Concurrent Update Reference）：</p>
<p>  真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</p>
</li>
<li><p>最终引用更新（Final Update Reference）：</p>
<p>  解决了堆中的引用更新后，还要修正存在于GC Roots 中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。</p>
</li>
<li><p>并发清理（Concurrent Cleanup ）：</p>
<p>  经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，这些Region都变成Immediate Garbage Regions了，最后再调用一次并发清理过程来回收 这些Region的内存空间，供以后新对象分配使用。</p>
</li>
</ul>
<p><img src="/media/17321588916542/17321669915068.jpg"></p>
<p><img src="/media/17321588916542/17321690862577.jpg"></p>
<h2 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h2><p>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>
<p>ZGC也采用基于Region的堆内存布局，但与它们不同的是，ZGC的Region（在一些官方资料中将它称为Page或者ZPage）具有动态性——动态创建和销毁，以及动态的区域容量大小。在x64硬件平台下，ZGC的 Region可以具有如图3-19所示的大、中、小三类容量：</p>
<ul>
<li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li>
<li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4M B的对 象。</li>
<li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4M B或以上的大对象。每个大型Region中只会存放一个大对象，这也预示着虽然名字叫作“大型Region”，但它的实际容量完全有可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。</li>
</ul>
<p><img src="/media/17321588916542/17321713938602.jpg"></p>
<p>ZGC收集器有一个标志性的设计是它采用的染色指针技术（Colored Pointer，其他类似的技术中可 能将它称为Tag Pointer或者Version Pointer）<br><img src="/media/17321588916542/17321718622056.jpg"></p>
<ul>
<li><p>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。这点相比起Shenandoah是一个颇大的优势，使得理论上只要还有一个空闲Region，ZGC就能完成收集，而Shenandoah需要等到引用 更新阶段结束以后才能释放回收集中的Region，这意味着堆中几乎所有对象都存活的极端情况，需要 1∶1复制对象到新Region的话，就必须要有一半的空闲Region来完成收集。至于为什么染色指针能够导致这样的结果，笔者将在后续解释其“自愈”特性的时候进行解释。</p>
</li>
<li><p>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的 目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些 专门的记录操作。实际上，到目前为止ZGC都并未使用任何写屏障，只使用了读屏障（一部分是染色指针的功劳，一部分是ZGC现在还不支持分代收集，天然就没有跨代引用的问题）。内存屏障对程序 运行时性能的损耗在前面章节中已经讲解过，能够省去一部分的内存屏障，显然对程序运行效率是大 有裨益的，所以ZGC对吞吐量的影响也相对较低。</p>
</li>
<li><p>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。现在Linux下的64位指针还有前18位并未使用，它们虽然不能用来寻址，却可 以通过其他手段用于信息记录。如果开发了这18位，既可以腾出已用的4个标志位，将ZGC可支持的 最大堆内存从4TB拓展到64TB，也可以利用其余位置再存储更多的标志，譬如存储一些追踪信息来让 垃圾收集器在移动对象时能将低频次使用的对象移动到不常访问的内存区域。</p>
</li>
</ul>
<ol>
<li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的 阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记（尽管ZGC中的名字不叫这些）的 短暂停顿，而且这些停顿阶段所做的事情在目标上也是相类似的。与G1、Shenandoah不同的是，ZGC 的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的M arked 0、M arked 1标志 位。</li>
<li>并发预备重分配（Concurrent Prep are for Relocate）：这个阶段需要根据特定的查询条件统计得出 本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。重分配集与G1收集器 的回收集（Collection Set）还是有区别的，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收。相反，ZGC每次回收都会扫描所有的Region，用范围更大的扫描成本换取省去G1中记忆集的 维护成本。因此，ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，里面 的Region会被释放，而并不能说回收行为就只是针对这个集合里面的Region进行，因为标记过程是针对 全堆的。此外，在JDK 12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li>
<li>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分 配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。得益于染色指针的支持，ZGC收集器能仅从引用上就明 确得知一个对象是否处于重分配集之中，如果用户线程此时并发访问了位于重分配集中的对象，这次 访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象 上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self- Healing）能力。这样做的好处是只有第一次访问旧对象会陷入转发，也就是只慢一次，对比 Shenandoah的Brooks转发指针，那是每次对象访问都必须付出的固定开销，简单地说就是每次都慢， 因此ZGC对用户程序的运行时负载要比Shenandoah来得更低一些。还有另外一个直接的好处是由于染 色指针的存在，一旦重分配集中某个Region的存活对象都复制完毕后，这个Region就可以立即释放用于 新对象的分配（但是转发表还得留着不能释放掉），哪怕堆中还有很多指向这个对象的未更新指针也 没有关系，这些旧指针一旦被使用，它们都是可以自愈的。</li>
<li>并发重映射（Concurrent Remap ）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所 有引用，这一点从目标角度看是与Shenandoah并发引用更新阶段一样的，但是ZGC的并发重映射并不 是一个必须要“迫切”去完成的任务，因为前面说过，即使是旧引用，它也是可以自愈的，最多只是第 一次使用时多一次转发和修正操作。重映射清理这些旧引用的主要目的是为了不变慢（还有清理结束 后可以释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC很巧妙地把并发重映射 阶段要做的工作，合并到了下一次垃圾收集循环中的并发标记阶段里去完成，反正它们都是要遍历所 有对象的，这样合并就节省了一次遍历对象图[9]的开销。一旦所有指针都被修正之后，原来记录新旧 对象关系的转发表就可以释放掉了。</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:39.583Z" title="2025/5/16 11:12:39">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">3 分钟读完 (大约393个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95/">可达性分析算法</a></p><div class="content"><br/>

<p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。<br><br/></p>
<p><img src="/media/17304386866747/17304388367110.jpg"></p>
<br/>

<h3 id="在Java技术体系里面，固定可作为GC-Roots的对象包括以下几种："><a href="#在Java技术体系里面，固定可作为GC-Roots的对象包括以下几种：" class="headerlink" title="在Java技术体系里面，固定可作为GC Roots的对象包括以下几种："></a>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</h3><br/>

<ol>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</li>
<li>在<strong>方法区中类静态属性</strong>引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在<strong>方法区中常量</strong>引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>在本地方法栈中JNI（即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</li>
</ol>
<br/>


</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:12:43.660Z" title="2025/5/16 11:12:43">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/java/">java</a></span><span class="level-item">5 分钟读完 (大约788个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/java/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5-%E5%9F%BA%E6%9C%AC%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/">基本垃圾回收算法</a></p><div class="content"><p>[TOC]</p>
<br/>

<blockquote>
<p>在对基本回收策略进行描述时，我们假设赋值器运行在一个或者多个线程之上，<br>且只有一个回收器线程，当回收器线程运行时，所有的赋值器线程均处于停止状态。这种<br><strong>万物静止(stop the world)</strong> 的策略大幅简化了回收器的实现。从赋值器线程角度来看，回收过程的执行是原子性的，即赋值器线程感知不到回收器的任何中间状态，回收器也不会受到赋值器线程的任何干扰。</p>
</blockquote>
<br/>

<h2 id="标记－清除（mark-sweep"><a href="#标记－清除（mark-sweep" class="headerlink" title="标记－清除（mark-sweep)"></a>标记－清除（mark-sweep)</h2><br/>

<p>回收过程分为两个阶段</p>
<ul>
<li>第一阶段为追踪(trace) 阶段，即回收器从根集合（寄存器、线程栈、全局变址）开始遍历对象图，并标记(mark) 所遇到的每个对象；</li>
<li>第二阶段为清扫 (sweep)阶段，即回收器检查堆中每一个对象，<br>并将所有<strong>未标记的对象</strong>当作垃圾进行回收。</li>
</ul>
<p><img src="/media/17304402487913/17306989696842.jpg"></p>
<p>主要缺点有两个：</p>
<ul>
<li>第一个是<strong>执行效率不稳定</strong>，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li>
<li>第二个是<strong>内存空间的碎片化问题</strong>，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<br/>

<h2 id="标记－复制-mark-copy"><a href="#标记－复制-mark-copy" class="headerlink" title="标记－复制 (mark-copy)"></a>标记－复制 (mark-copy)</h2><br/>

<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效。</p>
<p>这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费太多。标<br><img src="/media/17304402487913/17307003523033.jpg"></p>
<br/>

<h2 id="标记－整理-mark-compact"><a href="#标记－整理-mark-compact" class="headerlink" title="标记－整理 (mark-compact)"></a>标记－整理 (mark-compact)</h2><br/>

<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。</p>
<p><img src="/media/17304402487913/17307017755862.jpg"></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/java/">上一页</a></div><div class="pagination-next"><a href="/categories/java/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/java/">1</a></li><li><a class="pagination-link is-current" href="/categories/java/page/2/">2</a></li><li><a class="pagination-link" href="/categories/java/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="zcct"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zcct</p><p class="is-size-6 is-block">zcct</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/zclvct" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/GeoHash/">GeoHash</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/HyperLogLog/">HyperLogLog</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/Scan%E6%8C%87%E4%BB%A4/">Scan指令</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/Stream/">Stream</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/codis%20%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/">codis 集群方案</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">63</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E4%BC%98%E5%8C%96/"><span class="tag">sql优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"><span class="tag">事务处理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tag">内存模型</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7/"><span class="tag">架构安全性</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F/"><span class="tag">透明多级分流系统</span><span class="tag">6</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="ZCCT" height="28"></a><p class="is-size-7"><span>&copy; 2025 zcct</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>