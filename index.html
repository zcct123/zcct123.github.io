<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ZCCT</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ZCCT"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ZCCT"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ZCCT"><meta property="og:url" content="http://example.com/"><meta property="og:site_name" content="ZCCT"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/og_image.png"><meta property="article:author" content="zcct"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com"},"headline":"ZCCT","image":["http://example.com/img/og_image.png"],"author":{"@type":"Person","name":"zcct"},"publisher":{"@type":"Organization","name":"ZCCT","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="ZCCT" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">主页</a><a class="navbar-item" href="/archives">档案</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:55.755Z" title="2025/5/16 11:14:55">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">11 分钟读完 (大约1648个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/GeoHash/">GeoHash</a></p><div class="content"><p>[TOC]</p>
<p>Redis 在 3.2 版本以后增加了地理位置 GEO 模块</p>
<p>GeoHash 是一种将地理坐标（经度和纬度）编码为字符串的技术，主要用于空间索引和地理位置查询。它通过将经纬度信息编码成一个紧凑的字符串，使得相近的地理位置具有相似的 GeoHash 值，从而方便进行邻近搜索和区域查询。</p>
<p>主要特点</p>
<ul>
<li>紧凑性：GeoHash 编码后的字符串通常较短，便于存储和传输。</li>
<li>局部性：相邻的地理位置具有相似的 GeoHash 值，便于进行邻近搜索。</li>
<li>层次性：GeoHash 可以通过截取字符串的不同长度来实现不同精度的地理位置表示。</li>
<li>易于实现：GeoHash 的编码和解码算法相对简单，易于实现。</li>
</ul>
<p>GeoHash 的编码过程如下：</p>
<ol>
<li>经纬度范围划分：<ul>
<li>经度范围：-180° 到 180°</li>
<li>纬度范围：-90° 到 90°</li>
</ul>
</li>
<li>交替编码：<ul>
<li>将经度和纬度交替地划分为二进制区间。</li>
<li>每次划分后，将结果编码为一个二进制位。</li>
<li>经度和纬度的二进制位交替组合，形成最终的 GeoHash 编码。</li>
</ul>
</li>
<li>Base32 编码：<ul>
<li>为了提高可读性和减少存储空间，GeoHash 使用 Base32 编码将二进制位转换为字符。</li>
<li>Base32 字符集包含 32 个字符：0123456789bcdefghjkmnpqrstuvwxyz</li>
</ul>
</li>
</ol>
<h2 id="编码过程示例"><a href="#编码过程示例" class="headerlink" title="编码过程示例"></a>编码过程示例</h2><pre><code>1. 确定初始区间，经度为 [-180°, +180°]，纬度为 [-90°, +90°]。
2. 将初始区间对半拆分得到左半区间和右半区间，根据目标位置的经度或纬度是落在左区间还是右区间，决定当前位的二进制编码。左区间取 0，右区间取 1。
3. 对上一步中目标位置所在的子区间进行对半划分，按照同样的方式计算出下一位的二进制编码。
4. 重复划分上面的步骤，直到达到期望的编码长度。
</code></pre>
<ol>
<li><p><strong>进行二进制编码：</strong></p>
<p> 30.6599157 的 15 位二进制编码的过程：</p>
<p> 将 [-90°, 90°] 对半拆分得到 [-90°, 0°] 和 [0°, 90°]，30.6599157 位于右区间，取 1 。<br> 将 [0°, 90°] 对半拆分得到 [0°, 45°] 和 [45°, 90°]，30.6599157 位于左区间，取0</p>
<p> <img src="/media/17338872744775/17338939634169.jpg"></p>
<p> 通过以上计算，纬度 30.6599157 的二进制编码为：10101 01110 01101。</p>
<p> 经度 104.0638546 的 15 位二进制编码：</p>
<p> <img src="/media/17338872744775/17338940362457.jpg"><br> 经度 104.0638546 的二进制编码为 11001 01000 00000。</p>
</li>
<li><p><strong>交叉合并经度和纬度的二进制编码</strong><br> 从第 0 位开始，偶数位放经度，奇数位放纬度，得到完整的二进制编码：</p>
<p> <img src="/media/17338872744775/17339003579125.jpg"></p>
</li>
<li><p><strong>将二进制编码分组并计算出对应的 Base32 编码</strong></p>
<p> 二进制编码看起来很长，不方便记忆。为了压缩编码长度，geohash 采用了自己的 Base32 编码，将二进制编码转换成方便识别的文本。Geohash 所用的编码表由数字和字母组成，不过去掉了 a，i，l 和 o 四个字母：</p>
</li>
</ol>
<p><img src="/media/17338872744775/17339003304799.jpg"></p>
<h2 id="Geohash-解码"><a href="#Geohash-解码" class="headerlink" title="Geohash 解码"></a>Geohash 解码</h2><p>Geohash 的解码实际上编码的逆过程，先通过 Base32 编码表找出每个字符的十进制值，然后将十进制转为二进制，最后通过二进制计算出对应的区域范围。<br><img src="/media/17338872744775/17339002834284.jpg"></p>
<p>我们得出 wm6n2j 表示的是经度在 (104.062500, 104.073486) 之间，纬度在 (30.657349, 30.662842) 之间的一个矩形区域。</p>
<p>对比（latitude: 30.6599157, longitude: 104.0638546），它恰好在计算出来的范围之内。这个例子很好地说明了 geohash 是如何表示一个区域范围的。</p>
<h2 id="边界问题"><a href="#边界问题" class="headerlink" title="边界问题"></a>边界问题</h2><p>Geohash 将邻近搜索（proximity search）转换为了字符串前缀匹配，和基于经纬度的算法相比，极大地提高了计算效率。由于 geohash 是将地图划分为矩形网格，并单独对每个矩形进行编码，这就会带来以下问题。比如下图中有 A、B、C 三个点，要查找离 B 最近的点。可以发现，距离较远的 A 和 B 有着相同的 geohash 编码，而较近的 C 的 geohash 编码却有所不同。</p>
<p><img src="/media/17338872744775/17339004143080.jpg"></p>
<h2 id="非线性问题"><a href="#非线性问题" class="headerlink" title="非线性问题"></a>非线性问题</h2><p>Geohash 是基于经纬度的，它能反映出两个点在经纬度上面的距离，但是却不能反映出实际距离。在不同的纬度下，单位经度所表示的距离是不一样的。在赤道，单位经度对应的距离为 111.320km，而在 30°N 和 30°S，单位经度对应的距离为110.852km。</p>
<p>这种非线性问题并不是 geohash 和经纬度系统的问题，而是在于将球体表面的坐标映射到二维平面的坐标的不均匀性。在不同的纬度下，指定长度的 geohash 所表示的矩形区域大小也是不一样的。矩形用南北方向的高度（height）和东西方向的宽度（width）来衡量。例如在赤道：</p>
<p>Blake Haugen 在他的博客 Geohash Size Variation by Latitude 中展示了不同纬度下不同长度的 geohash 所表示的矩形区域的大小。当 geohash 长度相同时，矩形的高度在不同纬度下是相同的，而矩形的宽度在不同纬度下并不相同。这一点从经纬度的划分上很好理解，假设地球是一个完美的球体，经线圈的周长是相同的，而纬线圈的周长在赤道最大，越靠近两极越小并不断趋近于零。</p>
<h2 id="Redis-的-Geo-指令"><a href="#Redis-的-Geo-指令" class="headerlink" title="Redis 的 Geo 指令"></a>Redis 的 Geo 指令</h2><p>geoadd 指令携带集合名称以及多个经纬度名称三元组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd company 116.48105 39.996794 juejin</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.514203 39.905409 ireader</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.489033 40.007669 meituan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd company 116.562108 39.787602 jd 116.334255 40.027400 xiaomi</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>


<p>geodist 指令可以用来计算两个元素之间的距离，携带集合名称、2 个名称和距离单位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist company juejin ireader km</span><br><span class="line">&quot;10.5501&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin meituan km</span><br><span class="line">&quot;1.3878&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin jd km</span><br><span class="line">&quot;24.2739&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin xiaomi km</span><br><span class="line">&quot;12.9606&quot;</span><br><span class="line">127.0.0.1:6379&gt; geodist company juejin juejin km</span><br><span class="line">&quot;0.0000&quot;</span><br></pre></td></tr></table></figure>

<p>geopos 指令可以获取集合中任意元素的经纬度坐标，可以一次获取多个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">27.0.0.1:6379&gt; geopos company juejin</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">2) &quot;39.99679348858259686&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company ireader</span><br><span class="line">1) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">2) &quot;39.90540918662494363&quot;</span><br><span class="line">127.0.0.1:6379&gt; geopos company juejin ireader</span><br><span class="line">1) 1) &quot;116.48104995489120483&quot;</span><br><span class="line">2) &quot;39.99679348858259686&quot;</span><br><span class="line">2) 1) &quot;116.5142020583152771&quot;</span><br><span class="line">2) &quot;39.90540918662494363&quot;</span><br></pre></td></tr></table></figure>


<p>geohash 可以获取元素的经纬度编码字符串，上面已经提到，它是 base32 编码。 你可 以使用这个编码值去 <a target="_blank" rel="noopener" href="http://geohash.org/$%7Bhash%7D%E4%B8%AD%E8%BF%9B%E8%A1%8C%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D%EF%BC%8C%E5%AE%83%E6%98%AF">http://geohash.org/${hash}中进行直接定位，它是</a> geohash 的标准编码 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geohash company ireader</span><br><span class="line">1) &quot;wx4g52e1ce0&quot;</span><br><span class="line">127.0.0.1:6379&gt; geohash company juejin</span><br><span class="line">1) &quot;wx4gd94yjn0&quot;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:58.679Z" title="2025/5/16 11:14:58">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">23 分钟读完 (大约3439个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/HyperLogLog/">HyperLogLog</a></p><div class="content"><p>[TOC]</p>
<p>HyperLogLog 是一种用于估计大数据集中<strong>不同元素数量（即基数）的算法</strong>。它特别适用于处理大规模数据集，能够在占用较少内存的情况下提供高效的基数估算。以下是 HyperLogLog 的主要特点和工作原理</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>流量统计：网站或应用的独立访客数（UV）统计。</li>
<li>日志分析：分析日志文件中的唯一IP地址数量。</li>
<li>数据库系统：用于优化查询计划，估算表中的唯一值数量。</li>
<li>网络监控：监测网络流量中的唯一设备数量。</li>
</ul>
<h2 id="redis-HyperLogLog-使用"><a href="#redis-HyperLogLog-使用" class="headerlink" title="redis HyperLogLog 使用"></a>redis HyperLogLog 使用</h2><p>HyperLogLog 提供了两个指令 pfadd 和 pfcount，根据字面意义很好理解，一个是增加 计数，一个是获取计数。pfadd 用法和 set 集合的 sadd 是一样的，来一个用户 ID，就将用 户 ID 塞进去就是。pfcount 和 scard 用法是一样的，直接获取计数值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd codehole user1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount codehole</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; pfadd codehole user3</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h2 id="HyperLogLog-实现原理"><a href="#HyperLogLog-实现原理" class="headerlink" title="HyperLogLog 实现原理"></a>HyperLogLog 实现原理</h2><h3 id="伯努利实验与极大似然估计"><a href="#伯努利实验与极大似然估计" class="headerlink" title="伯努利实验与极大似然估计"></a>伯努利实验与极大似然估计</h3><h4 id="伯努利实验"><a href="#伯努利实验" class="headerlink" title="伯努利实验"></a>伯努利实验</h4><p>伯努利实验其实就是扔硬币，只有正反两面，且每一面朝上的概率都是50%。</p>
<ul>
<li><p>场景1：我们随机扔一次硬币，那么得到正面或反面的可能性是相同的。如果我们扔10000次硬币，那么可以估计到大概率是接近5000次正面，5000次反面。这是最简单的正向推测。</p>
</li>
<li><p>场景2：如果我们扔2次硬币，是否可能2次都是正面？当然有可能，并且概率为1&#x2F;4。如果我们扔10次硬币呢，是否可能10次都是正面？虽然概率很小，但依然是有可能的，概率为1&#x2F;1024。同样的，无论是100次、1000次，即使概率很小，也依然存在全部都是正面朝上的情况，假如扔了n次，那么n次都是正面的概率为<code>\frac&#123;1&#125;&#123;2^n&#125;</code></p>
</li>
<li><p>场景3：现在我们按下面这种规则扔硬币：不断扔硬币，如果是正面朝上，那么就继续扔，直到出现反面朝上，此时记录下扔硬币的总次数。例如我们抛了5次硬币，前4次都是正面朝上，第5次是反面朝上，我们就记录下次数5。通过场景2，我们可以知道这种情况发生的概率为1&#x2F;32。按我们的直觉可以推测，如果一个结果发生的概率是1&#x2F;32，那么我们大体上就需要做32次同样的事情才能得到这个结果（当然从更严谨的数学角度，并不能这么说，但本文不想涉及专业的数学描述，所以姑且这么理解，其实也挺符合一般常识判断的）</p>
</li>
</ul>
<p>那么假如张三做了若干次这种实验，我观察结果，发现记录下的总次数的最大值是5，那就说明在这若干次实验中，至少发生了一次4次正面朝上，第5次反面朝上的情况，而这种情况发生的概率是1&#x2F;32，于是我推测，张三大概率总共做了32次实验。这就是一种反向推测：即根据结果（发生了一次1&#x2F;32概率才会出现的结果），推测条件（大概率做了32次实验）。<br>更通俗来说，<strong>如果一个结果出现的概率很小，但却实际发生了了，就可以推测这件事情被重复执行了很多次。结果出现的概率越小，事情被重复执行的次数就应当越多</strong>。</p>
<h4 id="伯努利试验是数学概率论中的一部分内容，它的典故来源于抛硬币"><a href="#伯努利试验是数学概率论中的一部分内容，它的典故来源于抛硬币" class="headerlink" title="伯努利试验是数学概率论中的一部分内容，它的典故来源于抛硬币"></a>伯努利试验是数学概率论中的一部分内容，它的典故来源于抛硬币</h4><p>硬币拥有正反两面，一次的上抛至落下，最终出现正反面的概率都是50%。假设一直抛硬币，直到它出现正面为止，我们记录为一次完整的试验，间中可能抛了一次就出现了正面，也可能抛了4次才出现正面。无论抛了多少次，只要出现了正面，就记录为一次试验。这个试验就是伯努利试验。</p>
<p>那么对于多次的伯努利试验，假设这个多次为n次。就意味着出现了n次的正面。假设每次伯努利试验所经历了的抛掷次数为k。第一次伯努利试验，次数设为k1，以此类推，第n次对应的是kn。</p>
<p>其中，对于这n次伯努利试验中，必然会有一个最大的抛掷次数k，例如抛了12次才出现正面，那么称这个为k_max，代表抛了最多的次数。</p>
<p>伯努利试验容易得出有以下结论：</p>
<ul>
<li>n 次伯努利过程的投掷次数都不大于 k_max。</li>
<li>n 次伯努利过程，至少有一次投掷次数等于 k_max</li>
</ul>
<p>最终结合极大似然估算的方法，发现在n和k_max中存在估算关联：n &#x3D; <code>2^&#123;k_max&#125;</code> 。这种通过局部信息预估整体数据流特性的方法似乎有些超出我们的基本认知，需要用概率和统计的方法才能推导和验证这种关联关系。</p>
<blockquote>
<p>第一次试验: 抛了3次才出现正面，此时 k&#x3D;3，n&#x3D;1<br>第二次试验: 抛了2次才出现正面，此时 k&#x3D;2，n&#x3D;2<br>第三次试验: 抛了6次才出现正面，此时 k&#x3D;6，n&#x3D;3<br>第n 次试验：抛了12次才出现正面，此时我们估算，n &#x3D; <code>2^&#123;12&#125;</code></p>
</blockquote>
<p>假设上面例子中实验组数共3组，那么 k_max &#x3D; 6，最终 n&#x3D;3，我们放进估算公式中去，明显： 3 ≠ <code>2^6</code> 。也即是说，当试验次数很小的时候，这种估算方法的误差是很大的。</p>
<h4 id="估算的优化"><a href="#估算的优化" class="headerlink" title="估算的优化"></a>估算的优化</h4><p>如进行 100 轮或者更多轮次的试验，然后再取每轮的 k_max，再取平均数，即: k_mx&#x2F;100。最终再估算出 n。下面是LogLog的估算公式：</p>
<p><img src="/media/17338146135039/17338808342763.jpg"></p>
<p>面公式的DVLL对应的就是n，constant是修正因子，它的具体值是不定的，可以根据实际情况而分支设置。m代表的是试验的轮数。头上有一横的R就是平均数：(k_max_1 + … + k_max_m)&#x2F;m。</p>
<p>这种通过增加试验轮次，再取k_max平均数的算法优化就是LogLog的做法。而 <strong>HyperLogLog和LogLog的区别就是，它采用的不是平均数，而是调和平均数</strong>.调和平均数比平均数的好处就是不容易受到大的数值的影响</p>
<blockquote>
<p>求平均工资:<br>A的是1000&#x2F;月，B的30000&#x2F;月。采用平均数的方式就是： (1000 + 30000) &#x2F; 2 &#x3D; 15500<br>采用调和平均数的方式就是： 2&#x2F;(1&#x2F;1000 + 1&#x2F;30000) ≈ 1935.484</p>
</blockquote>
<p><img src="/media/17338146135039/17338809950262.jpg"></p>
<h3 id="redis中的具体数据结构"><a href="#redis中的具体数据结构" class="headerlink" title="redis中的具体数据结构"></a>redis中的具体数据结构</h3><p>redis使用了12kb的存储空间来存储hyperloglog的结果，那这12kb是如何具体分配的呢？接下去就来讨论这个部分。</p>
<h4 id="比特串"><a href="#比特串" class="headerlink" title="比特串"></a>比特串</h4><p>通过hash函数，将数据转为比特串，例如输入5，便转为：101。为什么要这样转化呢？</p>
<p>是因为要和抛硬币对应上，比特串中，0 代表了反面，1 代表了正面，如果一个数据最终被转化了 10010000，那么从右往左，从低位往高位看，我们可以认为，首次出现 1 的时候，就是正面。</p>
<p>那么基于上面的估算结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样也就可以根据存入数据中，转化后的出现了 1 的最大的位置 k_max 来估算存入了多少数据。</p>
<h4 id="redis的分桶"><a href="#redis的分桶" class="headerlink" title="redis的分桶"></a>redis的分桶</h4><p>要使用极大似然估计，需要可观察的结果足够多，但这个“足够多”其实并没有严谨的规定，和100比1万也挺多了，但和100万比较又显得少了，况且观察结果再多，误差总是有的，一些极端情况也是有可能发生的（就像有的人可能买一次彩票就中奖了，有的人可能买一辈子也没有中过）。为了减小这种误差，redis将统计结果分散到了总计16384个桶中，在最终计算总的结果的时候，再将这每一个桶的统计结果再做一次调和平均，使得各种极端情况的影响降到最低。</p>
<p>分桶就是分多少轮。抽象到计算机存储中去，就是存储的是一个以单位是比特(bit)，长度为 L 的大数组 S ，将 S 平均分为 m 组，注意这个 m 组，就是对应多少轮，然后每组所占有的比特个数是平均的，设为 P。容易得出下面的关系：</p>
<ul>
<li>L &#x3D; S.length</li>
<li>L &#x3D; m * p</li>
<li>以 K 为单位，S 占用的内存 &#x3D; L &#x2F; 8 &#x2F; 1024</li>
</ul>
<p>在 Redis 中，HyperLogLog设置为：m&#x3D;16834，p&#x3D;6，L&#x3D;16834 * 6。占用内存为&#x3D;16834 * 6 &#x2F; 8 &#x2F; 1024 &#x3D; 12K</p>
<h4 id="数据存储结构"><a href="#数据存储结构" class="headerlink" title="数据存储结构"></a>数据存储结构</h4><p>redis采用的hash算法能得到一个64bit的结果，前面讲到redis进行了分桶，于是为了确定这个hash的结果需要放到哪个桶中，就需要拿出14个bit来计算桶的序号，2的14次方正好是16384。<br>确定好放入哪个桶后，剩下的50个bit就作为扔硬币的实验结果，而最坏的实验结果是最左边的bit为1，其他bit都为0：10000….0000，此时我们需要记录的可能的最大数字就是50（即第一个为1的bit出现在第50位），而50的二进制是110010，需要6个bit存放。因此对于任意的hash结果，一个桶最多最多只需要6个bit就能存放下所有可能结果了<br>redis总共分了16384个桶，每个桶需要6bit，于是总计：16384×6+8+1024&#x3D; 12kb</p>
<p><img src="/media/17338146135039/17338194065078.jpg"></p>
<h4 id="稀疏结构与密集结构"><a href="#稀疏结构与密集结构" class="headerlink" title="稀疏结构与密集结构"></a>稀疏结构与密集结构</h4><p>当redis刚创建完一个hyperloglog结构的时候，其中的所有bit都为0。为了避免重复数据对存储空间的浪费，redis使用了几种特殊的数据结构来表示重复数据：</p>
<p><strong>ZERO</strong> : 一字节，表示连续多少个桶计数为0，前两位为标志00，后6位表示有多少个桶，最大为64。<br><strong>XZERO</strong> : 两个字节，表示连续多少个桶计数为0，前两位为标志01，后14位表示有多少个桶，最大为16384<br><strong>VAL</strong> : 一字节，表示连续多少个桶的计数为多少，前一位为标志1，四位表示连桶内计数，所以最大表示桶的计数为32。后两位表示连续多少个桶。<br>（ZERO和XZERO的区别在于如果连续为0的桶数量小于64个的时候，就没必要用14个bit来表示数量，进一步节约空间）<br><img src="/media/17338146135039/17338195397719.jpg"></p>
<p>当redis创建完一个新的hyperloglog结构时，因为其中的所有bit都为0，所以并不需要实际使用12kb的空间存放16384个0，而是用2个字节的XZERO来表示：</p>
<p><img src="/media/17338146135039/17338196143998.jpg"></p>
<p>经过用户的少数几次访问后，redis可能用如下结构存储：</p>
<p><img src="/media/17338146135039/17338196280944.jpg"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>设 APP 主页的 key 为： main<br>用户 id 为：idn , n-&gt;0,1,2,3….</p>
</blockquote>
<p>在这个统计问题中，不同的用户 id 标识了一个用户，那么我们可以把用户的 id 作为被hash的输入。即：</p>
<blockquote>
<p>hash(id) &#x3D; 比特串</p>
</blockquote>
<p>不同的用户 id，必然拥有不同的比特串。每一个比特串，也必然会至少出现一次 1 的位置。我们类比每一个比特串为一次伯努利试验。</p>
<p>现在要分轮，也就是分桶。所以我们可以设定，每个比特串的前多少位转为10进制后，其值就对应于所在桶的标号。假设比特串的低两位用来计算桶下标志，此时有一个用户的id的比特串是：1001011000011。它的所在桶下标为：11(2) &#x3D; 1<em>2^1 + 1</em>2^0 &#x3D; 3，处于第3个桶，即第3轮中。</p>
<p>上面例子中，计算出桶号后，剩下的比特串是：10010110000，从低位到高位看，第一次出现 1 的位置是 5 。也就是说，此时第3个桶，第3轮的试验中，k_max &#x3D; 5。5 对应的二进制是：101，又因为每个桶有 p 个比特位。当 p&gt;&#x3D;3 时，便可以将 101 存进去。</p>
<p>模仿上面的流程，多个不同的用户 id，就被分散到不同的桶中去了，且每个桶有其 k_max。然后当要统计出 mian 页面有多少用户点击量的时候，就是一次估算。最终结合所有桶中的 k_max，代入估算公式，便能得出估算值。</p>
<p><img src="/media/17338146135039/17338790587681.jpg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:02.904Z" title="2025/5/16 11:15:02">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">2 分钟读完 (大约365个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/PubSub%20%E6%B6%88%E6%81%AF%E5%A4%9A%E6%92%AD%20(%E7%BC%BA%E7%82%B9%E5%A4%9A%E4%B8%8D%E8%A2%AB%E4%BD%BF%E7%94%A8)/">PubSub 消息多播</a></p><div class="content"><p>[TOC]</p>
<p>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系</p>
<p><img src="/media/17344020048927/17344021594959.jpg"><br>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br><img src="/media/17344020048927/17344021742234.jpg"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Terminal 1：订阅频道</span><br><span class="line">127.0.0.1:6379&gt; SUBSCRIBE channel1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;channel1&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"></span><br><span class="line"># Terminal 2：发布消息</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH channel1 &quot;Hello, subscribers!&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># Terminal 1：接收到消息</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;channel1&quot;</span><br><span class="line">3) &quot;Hello, subscribers!&quot;</span><br></pre></td></tr></table></figure>

<p>PubSub 的生产者传递过来一个消息，Redis 会直接找到相应的消费者传递过去。如果一 个消费者都没有，那么消息直接丢弃。如果开始有三个消费者，一个消费者突然挂掉了，生 产者会继续发送消息，另外两个消费者可以持续收到消息。但是挂掉的消费者重新连上的时 候，这断连期间生产者发送的消息，对于这个消费者来说就是彻底丢失了。<br>如果 Redis 停机重启，PubSub 的消息是不会持久化的，毕竟 Redis 宕机就相当于一个 消费者都没有，所有的消息直接被丢弃。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:14:48.925Z" title="2025/5/16 11:14:48">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">几秒读完 (大约5个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/codis%20%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/">codis 集群方案</a></p><div class="content"><p><a target="_blank" rel="noopener" href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:28.663Z" title="2025/5/16 11:15:28">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">12 分钟读完 (大约1749个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/Stream/">Stream</a></p><div class="content"><p>[TOC]</p>
<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub&#x2F;sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p>
<p>简单来说发布订阅 (pub&#x2F;sub) 可以分发消息，但无法记录历史消息。</p>
<p>而 *<em>Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失</em>。</p>
<p><img src="/media/17345690191419/17345704082552.jpg"></p>
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消息时自动创建。</p>
<ul>
<li><p><strong>Consumer Group</strong> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</p>
</li>
<li><p><strong>last_delivered_id</strong> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</p>
</li>
<li><p><strong>pending_ids</strong> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</p>
</li>
</ul>
<h2 id="Redis-Stream角色关系"><a href="#Redis-Stream角色关系" class="headerlink" title="Redis Stream角色关系"></a>Redis Stream角色关系</h2><ol>
<li><p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 xadd 指令追加消 息时自动创建。</p>
</li>
<li><p>每个 Stream 都可以有多个消费组，每个消费组会有个游标last_delivered_id 在 Stream 数组之上往前移动，表示当前消费组已经消费到哪条消息了。每个消费组都有一个 Stream 内唯一的名称，消费组不会自动创建，它需要单独的指令 xgroup create 进行创建，需要指定 从 Stream 的某个消息 ID 开始消费，这个 ID 用来初始化 last_delivered_id 变量。</p>
</li>
<li><p>每个消费组 (Consumer Group) 的状态都是独立的，相互不受影响。也就是说同一份 Stream 内部的消息会被每个消费组都消费到。</p>
</li>
<li><p>同一个消费组 (Consumer Group) 可以挂接多个消费者 (Consumer)，这些消费者之间是竞争关系，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。每个消费者有一个组内唯一名称</p>
</li>
<li><p>消费者 (Consumer) 内部会有个状态变量 pending_ids，它记录了当前已经被客户端读取 的消息，但是还没有 ack。如果客户端没有 ack，这个变量里面的消息 ID 会越来越多，一 旦某个消息被 ack，它就开始减少。这个 pending_ids 变量在 Redis 官方被称之为 PEL，也就是 Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</p>
</li>
</ol>
<h3 id="消息队列相关命令："><a href="#消息队列相关命令：" class="headerlink" title="消息队列相关命令："></a>消息队列相关命令：</h3><pre><code>XADD - 添加消息到末尾
XTRIM - 对流进行修剪，限制长度
XDEL - 删除消息
XLEN - 获取流包含的元素数量，即消息长度
XRANGE - 获取消息列表，会自动过滤已经删除的消息
XREVRANGE - 反向获取消息列表，ID 从大到小
XREAD - 以阻塞或非阻塞方式获取消息列表
</code></pre>
<h3 id="消费者组相关命令："><a href="#消费者组相关命令：" class="headerlink" title="消费者组相关命令："></a>消费者组相关命令：</h3><pre><code>XGROUP CREATE - 创建消费者组
XREADGROUP GROUP - 读取消费者组中的消息
XACK - 将消息标记为&quot;已处理&quot;
XGROUP SETID - 为消费者组设置新的最后递送消息ID
XGROUP DELCONSUMER - 删除消费者
XGROUP DESTROY - 删除消费者组
XPENDING - 显示待处理消息的相关信息
XCLAIM - 转移消息的归属权
XINFO - 查看流和消费者组的相关信息；
XINFO GROUPS - 打印消费者组的信息；
XINFO STREAM - 打印流信息
</code></pre>
<h3 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h3><p>Redis 设计了一个单独的消费指令 xread，可以将 Stream 当成普 通的消息队列 (list) 来使用。使用 xread 时，我们可以完全忽略消费组 (Consumer Group) 的存在，就好比 Stream 就是一个普通的列表 (list)。</p>
<p>客户端如果想要使用 xread 进行顺序消费，一定要记住当前消费到哪里了，也就是返回 的消息 ID。下次继续调用 xread 时，将上次返回的最后一个消息 ID 作为参数传递进去， 就可以继续消费后续的消息。<br>block 0 表示永远阻塞，直到消息到来，block 1000 表示阻塞 1s，如果 1s 内没有任何 消息到来，就返回 nil。</p>
<h3 id="消费"><a href="#消费" class="headerlink" title="消费"></a>消费</h3><p>Stream 提供了 xreadgroup 指令可以进行消费组的组内消费，需要提供消费组名称、消 费者名称和起始消息 ID。它同 xread 一样，也可以阻塞等待新消息。读到新消息后，对应的消息 ID 就会进入消费者的 PEL(正在处理的消息) 结构里，客户端处理完毕后使用 xack 指令通知服务器，本条消息已经处理完毕，该消息 ID 就会从 PEL 中移除。</p>
<h3 id="Stream-消息太多怎么办"><a href="#Stream-消息太多怎么办" class="headerlink" title="Stream 消息太多怎么办?"></a>Stream 消息太多怎么办?</h3><p>读者很容易想到，要是消息积累太多，Stream 的链表岂不是很长，内容会不会爆掉?xdel 指令又不会删除消息，它只是给消息做了个标志位。<br>Redis 自然考虑到了这一点，所以它提供了一个定长 Stream 功能。在 xadd 的指令提供 一个定长长度 maxlen，就可以将老的消息干掉，确保最多不超过指定长度。</p>
<h3 id="消息如果忘记-ACK-会怎样"><a href="#消息如果忘记-ACK-会怎样" class="headerlink" title="消息如果忘记  ACK 会怎样?"></a>消息如果忘记  ACK 会怎样?</h3><p>Stream 在每个消费者结构中保存了正在处理中的消息 ID 列表 PEL，如果消费者收到了消息处理完了但是没有回复 ack，就会导致 PEL 列表不断增长，如果有很多消费组的话，那么这个 PEL 占用的内存就会放大。</p>
<p><img src="/media/17345690191419/17345730397058.jpg"></p>
<h3 id="PEL-如何避免消息丢失"><a href="#PEL-如何避免消息丢失" class="headerlink" title="PEL 如何避免消息丢失?"></a>PEL 如何避免消息丢失?</h3><p>在客户端消费者读取 Stream 消息时，Redis 服务器将消息回复给客户端的过程中，客户端突然断开了连接，消息就丢失了。但是 PEL 里已经保存了发出去的消息 ID。待客户端 重新连上之后，可以再次收到 PEL 中的消息 ID 列表。不过此时 xreadgroup 的起始消息ID不能为参数&gt;，而必须是任意有效的消息 ID，一般将参数设为 0-0，表示读取所有的 PEL 消息以及自 last_delivered_id 之后的新消息</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:22.630Z" title="2025/5/16 11:15:22">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">5 分钟读完 (大约679个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/Scan%E6%8C%87%E4%BB%A4/">Scan指令</a></p><div class="content"><p><strong>SCAN 指令是 Redis 提供的一个用于迭代数据库键的命令</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]</span><br></pre></td></tr></table></figure>

<ul>
<li>cursor: 迭代器游标，初始值为 0，每次调用 SCAN 后会返回一个新的游标值，直到返回 0 表示迭代结束。</li>
<li>MATCH pattern: 可选参数，用于匹配特定模式的键，例如 MATCH user:* 会匹配所有以 user: 开头的键。</li>
<li>COUNT count: 可选参数，用于指定每次迭代返回的大致键数量，默认值为 10。</li>
<li>TYPE type: 可选参数，用于指定返回的键的类型，例如 TYPE string 会返回所有字符串类型的键。</li>
</ul>
<p><strong>SCAN 命令返回一个包含两个元素的数组</strong>：</p>
<p>第一个元素是下一个游标的值。<br>第二个元素是一个包含当前迭代结果的数组。</p>
<p>SCAN 命令，以及其他增量式迭代命令， 在进行完整遍历的情况下可以为用户带来以下保证：从完整遍历开始直到完整遍历结束期间，一直存在于数据集内的所有元素都会被完整遍历返回；这意味着，如果有一个元素，它从遍历开始直到遍历结束期间都存在于被遍历的数据集当中，那么 SCAN 命令总会在某次迭代中将这个元素返回给用户。</p>
<p>因为<strong>增量式命令仅仅使用游标来记录迭代状态，所以这些命令带有以下缺点</strong>：</p>
<ul>
<li>同一个元素可能会被返回多次。处理重复元素的工作交由应用程序负责，比如说， 可以考虑将迭代返回的元素仅仅用于可以安全地重复执行多次的操作上。</li>
<li>如果一个元素是在迭代过程中被添加到数据集的，又或者是在迭代过程中从数据集中被删除的， 那么这个元素可能会被返回，也可能不会， 这是未定义的（undefined）。</li>
</ul>
<h2 id="Scan遍历顺序"><a href="#Scan遍历顺序" class="headerlink" title="Scan遍历顺序"></a>Scan遍历顺序</h2><p>如果不考虑扩容与缩容,那么无论是从前遍历还是从后遍历都可以获取所有的key值,但是有扩容,缩容后就需要考虑遍历的准确性,是否存在重复遍历,是否存在遗漏的遍历.如果我们按照低位加法,即从前向后遍历,当扩容或者缩容时进行的rehash操作使得数据分散到不同的槽位,这就有可能发生重复遍历与遗漏遍历的情况.</p>
<p><img src="/media/17343144594237/17343167799678.jpg"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:19.054Z" title="2025/5/16 11:15:19">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">3 分钟读完 (大约498个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/redis%20list%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/">redis list应用——延迟队列</a></p><div class="content"><h2 id="异步消息队列"><a href="#异步消息队列" class="headerlink" title="异步消息队列"></a>异步消息队列</h2><p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用rpush&#x2F;lpush 操作入队列， 使用 lpop  和 rpop 来出队列。</p>
<p><img src="/media/17338134648030/17338135240562.jpg"></p>
<p>客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息， 再进行处理。如此循环往复。</p>
<p>可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop， 又没有数据。这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。通常我们使用 sleep 来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但客户端 的 CPU 能降下来，Redis 的 QPS 也降下来了。</p>
<p>blpop&#x2F;brpop 前缀字符 b 代表的是 blocking，也就是阻塞读。<br>阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消 息的延迟几乎为零。用 blpop&#x2F;brpop 替代前面的 lpop&#x2F;rpop，就完美解决了队列空了。…</p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作 为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期 的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处 理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:15.854Z" title="2025/5/16 11:15:15">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">3 分钟读完 (大约452个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/redis%20%E4%BD%8D%E5%9B%BE/">redis 位图</a></p><div class="content"><p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们 可以使用普通的 get&#x2F;set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit&#x2F;setbit 等将 byte 数组看成「位数组」来处理。</p>
<p>Redis 的位数组是自动扩展，如果设置了某个偏移位置超出了现有的内容范围，就会自 动将位数组进行零扩充。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit s 1 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; setbit s 2 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; setbit s 4 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; setbit s 9 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; setbit s 10 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; setbit s 13 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; setbit s 15 1 (integer) 0 </span><br><span class="line">127.0.0.1:6379&gt; get s &quot;he&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; set w h  # 整存 (integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit w 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 4 (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit w 5 (integer) 0</span><br></pre></td></tr></table></figure>
<h2 id="统计和查找"><a href="#统计和查找" class="headerlink" title="统计和查找"></a>统计和查找</h2><p>Redis 提供了位图统计指令 bitcount 和位图查找指令 bitpos，bitcount 用来统计指定位置范围内 1 的个数，bitpos 用来查找指定范围内出现的第一个 0 或 1。<br>比如我们可以通过 bitcount 统计用户一共签到了多少天，通过 bitpos 指令查找用户从哪一天开始第一次签到。如果指定了范围参数[start, end]，就可以统计在某个时间范围内用户签到了多少天，用户自某天以后的哪天开始签到。<br>遗憾的是， start 和 end 参数是字节索引，也就是说指定的位范围必须是 8 的倍数， 而不能任意指定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitcount w</span><br><span class="line">(integer) 21</span><br><span class="line">127.0.0.1:6379&gt; bitcount w 0 0  # 第一个字符中 1 的位数 (integer) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount w 0 1  # 前两个字符中 1 的位数 (integer) 7</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; bitpos w 0  # 第一个 0 位</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1  #  第一个 1 位</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1 1 1  # 从第二个字符算起，第一个 1 位 (integer) 9</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1 2 2  # 从第三个字符算起，第一个 1 位 (integer) 17</span><br></pre></td></tr></table></figure>

<h2 id="大规模标签查找"><a href="#大规模标签查找" class="headerlink" title="大规模标签查找"></a>大规模标签查找</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:12.983Z" title="2025/5/16 11:15:12">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">4 分钟读完 (大约671个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/redis%20%E4%BA%8B%E5%8A%A1/">redis 事务</a></p><div class="content"><p>[TOC]</p>
<p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<h3 id="事务相关指令"><a href="#事务相关指令" class="headerlink" title="事务相关指令"></a>事务相关指令</h3><p> Redis事务相关命令和使用MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。</p>
<ul>
<li>MULTI ：开启事务，redis会将后续的命令逐个放入队列中，然后使用EXEC命令来原子化执行这个命令系列。</li>
<li>EXEC：执行事务中的所有操作命令。</li>
<li>DISCARD：取消事务，放弃执行事务块中的所有命令。</li>
<li>WATCH：监视一个或多个key,如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令。</li>
<li>UNWATCH：取消WATCH对所有key的监视。</li>
</ul>
<blockquote>
<p>所有的指令在 exec 之前不执行，而是缓存在 服务器的一个事务队列中，服务器一旦收到 exec 指令，才开执行整个事务队列，执行完毕 后一次性返回所有指令的运行结果</p>
</blockquote>
<blockquote>
<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。</p>
</blockquote>
<h3 id="事务使用示例"><a href="#事务使用示例" class="headerlink" title="事务使用示例"></a>事务使用示例</h3><ol>
<li><p>执行事务<br><img src="/media/17343995161167/17344012727302.jpg"></p>
</li>
<li><p>取消事务<br><img src="/media/17343995161167/17344012962893.jpg"></p>
</li>
<li><p>在事务队列中存在语法性错误，则执行EXEC命令时，所有命令都不会执行</p>
<p> <img src="/media/17343995161167/17344013514390.jpg"></p>
</li>
<li><p>在事务队列中存在指令执行错误，则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常。</p>
<p> <img src="/media/17343995161167/17344014153275.jpg"></p>
</li>
<li><p>watch</p>
<ul>
<li>使用watch检测balance，事务期间balance数据未变动，事务执行成功。</li>
</ul>
<p> <img src="/media/17343995161167/17344014816147.jpg">    </p>
<ul>
<li>使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。</li>
</ul>
<p> <img src="/media/17343995161167/17344015348185.jpg"></p>
</li>
</ol>
<h3 id="为什么有-WATCH-命令"><a href="#为什么有-WATCH-命令" class="headerlink" title="为什么有 WATCH 命令"></a>为什么有 WATCH 命令</h3><p>在redis的事务中， 无法使用get操作获取value，get操作往往放在事务外面，为保证并发问题，需要watch命令监控get的key不被更改</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2024-09-01T04:00:00.000Z" title="2024/9/1 12:00:00">2024-09-01</time>发表</span><span class="level-item"><time dateTime="2025-05-16T03:15:06.616Z" title="2025/5/16 11:15:06">2025-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/redis/">redis</a></span><span class="level-item">3 分钟读完 (大约487个字)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/01/redis/redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">redis 分布式锁</a></p><div class="content"><p>[TOC]</p>
<blockquote>
<p>setnx lock:codehole true<br>OK<br>… do something critical …<br>del lock:codehole</p>
</blockquote>
<p>逻辑执行到中间出现异常了，可能会导致 del 指令没有被调用，这样 就会陷入死锁，锁永远得不到释放。于是我们在拿到锁之后，再给锁加上一个过期时间，比如 5s，这样即使中间出现异常也 可以保证 5 秒之后锁会自动释放。</p>
<blockquote>
<p>setnx lock:codehole true<br>OK<br>expire lock:codehole 5<br>… do something critical …<br>del lock:codehole (integer) 1</p>
</blockquote>
<p>如果在 setnx 和 expire 之间服务器进程突然挂掉了，可能是因 为机器掉电或者是被人为杀掉的，就会导致 expire 得不到执行，也会造成死锁。</p>
<p>Redis 2.8 版本中作者加入了 set 指令的扩展参数，使得 setnx 和 expire 指令可以一起执行。 </p>
<blockquote>
<p>set lock:codehole true ex 5 nx OK<br>… do something critical …<br>del lock:codehole<br>上面这个指令就是 setnx 和 expire 组合在一起的原子指令。</p>
</blockquote>
<h2 id="超时问题"><a href="#超时问题" class="headerlink" title="超时问题"></a>超时问题</h2><p>如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。</p>
<p>有一个更加安全的方案是为 set 指令的 value 参数设置为一个随机数，释放锁时先匹配 随机数是否一致，然后再删除 key。但是匹配 value 和删除 key 不是一个原子操作，Redis 也 没有提供类似于 delifequals 这样的指令，这就需要使用 Lua 脚本来处理了，因为 Lua 脚本可以保证连续多个指令的原子性执行。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/7/">7</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="zcct"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">zcct</p><p class="is-size-6 is-block">zcct</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives/"><p class="title">64</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories/"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags/"><p class="title">12</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gitee.com/zclvct" target="_blank" rel="me noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://gitee.com/zclvct"><i class="fab fa-github"></i></a></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/GeoHash/">GeoHash</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/HyperLogLog/">HyperLogLog</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/PubSub%20%E6%B6%88%E6%81%AF%E5%A4%9A%E6%92%AD%20(%E7%BC%BA%E7%82%B9%E5%A4%9A%E4%B8%8D%E8%A2%AB%E4%BD%BF%E7%94%A8)/">PubSub 消息多播</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/codis%20%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/">codis 集群方案</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-01T04:00:00.000Z">2024-09-01</time></p><p class="title"><a href="/2024/09/01/redis/Stream/">Stream</a></p><p class="categories"><a href="/categories/redis/">redis</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">九月 2024</span></span><span class="level-end"><span class="level-item tag">63</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/09/"><span class="level-start"><span class="level-item">九月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">30</span></span></a></li><li><a class="level is-mobile" href="/categories/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/redis/"><span class="level-start"><span class="level-item">redis</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="level-start"><span class="level-item">分布式</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/juc/"><span class="tag">juc</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jvm/"><span class="tag">jvm</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag">17</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E4%BC%98%E5%8C%96/"><span class="tag">sql优化</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"><span class="tag">事务处理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"><span class="tag">内存模型</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"><span class="tag">垃圾回收</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tag">多线程</span><span class="tag">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%B6%E6%9E%84%E5%AE%89%E5%85%A8%E6%80%A7/"><span class="tag">架构安全性</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"><span class="tag">类加载</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%8F%E6%98%8E%E5%A4%9A%E7%BA%A7%E5%88%86%E6%B5%81%E7%B3%BB%E7%BB%9F/"><span class="tag">透明多级分流系统</span><span class="tag">6</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="ZCCT" height="28"></a><p class="is-size-7"><span>&copy; 2025 zcct</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>